<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Multiplication Area Explorer</title>

<style>
/* ──────────── colour palette ──────────── */
:root{
  --goal-col:   #1565c0;                      /* blue  */
  --start-col:  #2e7d32;                      /* green */
  --user-col:   #ff9800;                      /* yellow*/

  --goal-rgba:  rgba(21,101,192,.25);
  --start-rgba: rgba(46,125,50,.25);
  --user-rgba:  rgba(255,152,0,.25);

  --lt-grey:#f5f5f5;
  --md-grey:#d0d0d0;
  --dk-grey:#444;
  --shadow :0 4px 10px rgba(0,0,0,.08);
}
/* ──────────── base reset ──────────── */
*{box-sizing:border-box;margin:0;padding:0}
body{
  font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  background:var(--lt-grey);
  color:var(--dk-grey);
  display:flex;justify-content:center;padding:1rem
}
/* ──────────── card wrapper ──────────── */
.card{
  width:100%;max-width:860px;padding:1.4rem 1.6rem;
  background:#fff;border-radius:8px;box-shadow:var(--shadow)
}
h2{font-size:1.75rem;margin-bottom:.4rem;color:var(--goal-col);text-align:center}
.tab-bar{display:flex;margin-bottom:1rem;border-bottom:2px solid var(--md-grey)}
.tab{
  flex:1;text-align:center;padding:.6rem 0;cursor:pointer;font-weight:500;
  border-bottom:3px solid transparent
}
.tab.active{border-color:var(--goal-col);color:var(--goal-col)}
/* ──────────── info panel ──────────── */
.info{background:var(--lt-grey);border:1px solid var(--md-grey);
      border-radius:6px;padding:1rem;margin-bottom:1rem;text-align:center;min-height:92px}
.info p{margin:.25rem 0}
.info b{font-weight:600}
.info .eq{margin-top:.8rem;font-style:italic}
/* ──────────── grid ──────────── */
.wrap{position:relative;display:inline-block;cursor:crosshair}
.box{overflow:auto}
table{border-collapse:collapse}
th,td{
  width:42px;height:42px;border:1px solid var(--md-grey);
  text-align:center;font-size:.9rem;user-select:none
}
th{background:var(--lt-grey);font-weight:600}
td{background:#fff;cursor:pointer}
/* ──────────── overlay rectangles ──────────── */
.layer{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none}
.rect{position:absolute;border-radius:2px}
.goal  {background:var(--goal-rgba);  border:2px solid var(--goal-col)}
.start {background:var(--start-rgba); border:2px solid var(--start-col)}
.user  {background:var(--user-rgba);  border:2px solid var(--user-col)}
.preview{background:rgba(0,0,0,.10);border:1px dashed var(--dk-grey)}
/* ──────────── buttons ──────────── */
.btn-bar{display:flex;flex-wrap:wrap;justify-content:center;gap:1rem;margin-top:1.2rem}
button{
  border:none;border-radius:4px;padding:9px 14px;color:#fff;cursor:pointer;font-weight:500
}
.clear{background:#d32f2f}
.swap {background:#6c6f75}
.check{background:#4caf50}
button:disabled{opacity:.5;cursor:default}
#sentence{display:none}
</style>
</head>
<body>

<div class="card">
  <h2>Multiplication Area Explorer</h2>

  <!-- tabs -->
  <div class="tab-bar">
    <div class="tab active" data-tab="visual">Visual Explorer</div>
    <div class="tab"        data-tab="sentence">Number Sentence</div>
  </div>

  <!-- info / equation panel -->
  <div id="info" class="info"></div>

  <!-- grid -->
  <div class="wrap" id="wrap">
    <div class="box"  id="box"></div>
    <div class="layer" id="layer"></div>
  </div>

  <!-- buttons -->
  <div class="btn-bar">
    <button class="clear" id="clear">Clear All</button>
    <button class="swap"  id="swap" disabled>Swap Selections</button>
    <!-- “Check” gets injected once all pieces are drawn -->
  </div>

  <!-- number-sentence tab -->
  <div id="sentence"></div>
</div>

<script>
/* ──────────────────────── helpers ──────────────────────── */
const N = 12;                                              // grid size
const $ = id => document.getElementById(id);
const box   = $('box');
const layer = $('layer');
const info  = $('info');
const wrap  = $('wrap');
const swapB = $('swap');
const clearB= $('clear');
const sentenceTab = $('sentence');
const tabEls = document.querySelectorAll('.tab');

/* canonicalise rectangle {r1,c1,r2,c2} so r1<=r2, c1<=c2 */
const canon = r => {
  const r1 = Math.min(r.r1,r.r2), c1 = Math.min(r.c1,r.c2),
        r2 = Math.max(r.r1,r.r2), c2 = Math.max(r.c1,r.c2);
  return {r1,c1,r2,c2};
};

const area = r => (r.r2 - r.r1 + 1) * (r.c2 - r.c1 + 1);
const sameRect = (a,b) => a.r1===b.r1&&a.c1===b.c1&&a.r2===b.r2&&a.c2===b.c2;

/* ──────────────────────── build grid ───────────────────── */
const makeGrid = () => {
  let h='<table id="grid"><thead><tr><th></th>';
  for(let c=1;c<=N;c++) h+=`<th>${c}</th>`;
  h+='</tr></thead><tbody>';
  for(let r=1;r<=N;r++){
    h+=`<tr><th>${r}</th>`;
    for(let c=1;c<=N;c++) h+=`<td data-r="${r}" data-c="${c}"></td>`;
    h+='</tr>';
  }
  box.innerHTML = h+'</tbody></table>';
};
makeGrid();

/* ──────────────────────── state ────────────────────────── */
const S = {
  first:null,            // first click {r,c}
  goal:null,             // larger {r,c}
  start:null,            // smaller {r,c}
  solution:[],           // required transfer rectangles
  drawn:[],              // user-accepted rectangles
  dragging:false,
  dragStart:null
};

/* ───────────────────── overlay drawing ─────────────────── */
const cellRect = (r,c) => {
  const t = $('grid');
  const td = t.querySelector(`td[data-r="${r}"][data-c="${c}"]`);
  const base = box.getBoundingClientRect();
  const rect = td.getBoundingClientRect();
  return {x:rect.left-base.left,y:rect.top-base.top,w:rect.width,h:rect.height};
};
const extentRect = (r1,c1,r2,c2) => {
  const {w,h} = cellRect(1,1);
  const x0=Math.min(c1,c2)-1, y0=Math.min(r1,r2)-1;
  return {left:x0*w, top:y0*h, width:(Math.abs(c1-c2)+1)*w, height:(Math.abs(r1-r2)+1)*h};
};
const addRect = (ext,cls,idx=null) => {
  const d=document.createElement('div');
  d.className=`rect ${cls}`;
  d.style.cssText=`left:${ext.left}px;top:${ext.top}px;width:${ext.width}px;height:${ext.height}px`;
  if(idx!==null){ d.dataset.idx=idx; d.style.cursor='pointer'; }
  layer.appendChild(d);
};
const paint = () => {
  layer.innerHTML='';
  if(S.goal)  addRect(extentRect(1,1,S.goal.r,S.goal.c),'goal');
  if(S.start) addRect(extentRect(1,1,S.start.r,S.start.c),'start');
  S.drawn.forEach((r,i)=> addRect(extentRect(r.r1,r.c1,r.r2,r.c2),'user',i));
};

/* ─────────────────── solution generation ───────────────── */
const genSolution = () => {
  const {goal,start}=S;
  if(!goal||!start) return [];
  const sol=[];
  if(start.r < goal.r){ // vertical strip
    sol.push({r1:start.r+1,c1:1,r2:goal.r,c2:goal.c});
  }
  if(start.c < goal.c){ // horizontal strip
    sol.push({r1:1,c1:start.c+1,r2:start.r,c2:goal.c});
  }
  return sol.map(canon);
};

/* ─────────────────── info / sentence panels ────────────── */
const updateInfo = (msgEq='') =>{
  if(!S.goal){
    info.innerHTML='<p>Click a cell to choose your <b>Goal Area</b>.</p>'; return;
  }
  if(!S.start){
    info.innerHTML=`<p>Goal Area: <b>${S.goal.r}×${S.goal.c}</b> = ${S.goal.r*S.goal.c}</p>
                    <p>Now pick a <b>Start Area</b>.</p>`; return;
  }
  info.innerHTML=`<p style="color:var(--goal-col)">Goal: <b>${S.goal.r}×${S.goal.c}</b> = ${S.goal.r*S.goal.c}</p>
                  <p style="color:var(--start-col)">Start: <b>${S.start.r}×${S.start.c}</b> = ${S.start.r*S.start.c}</p>
                  <p>Draw the missing rectangle${S.solution.length>1?'s':''}.</p>
                  ${msgEq}`;
};
const updateSentenceTab = () =>{
  if(!S.goal||!S.start) {sentenceTab.innerHTML='';return;}
  let terms=[`${S.start.r}×${S.start.c}`];
  S.drawn.forEach(r=>terms.push(`${r.r2-r.r1+1}×${r.c2-r.c1+1}`));
  const expr = `${S.goal.r}×${S.goal.c} = ${terms.join(' + ')}`;
  const areas = `${S.goal.r*S.goal.c} = ${terms.map(t=>{
      const [a,b]=t.split('×').map(Number);return a*b;}).join(' + ')}`;
  sentenceTab.innerHTML=`<h3 style="margin-bottom:.5rem">Number Sentence</h3>
     <p>${expr}</p><p>${areas}</p>`;
};

/* ───────────────── buttons / tabs ──────────────────────── */
const updateButtons = ()=>{
  swapB.disabled = !(S.goal&&S.start);
  // add/remove Check button
  const bar=document.querySelector('.btn-bar');
  bar.querySelector('.check')?.remove();
  const solved = S.drawn.length===S.solution.length && S.solution.every(sol =>
      S.drawn.some(d=>sameRect(d,sol)));
  if(solved){
    const btn=document.createElement('button');
    btn.className='check';btn.textContent='Check My Work';
    btn.onclick=()=>updateInfo('<span style="color:var(--user-col)">Nice! Everything matches.</span>');
    bar.appendChild(btn);
  }
};

/* ─────────────────── click-cell handling ───────────────── */
const cellFromEl = el => el.dataset ? {r:+el.dataset.r,c:+el.dataset.c} : null;

box.addEventListener('click',e=>{
  const cell=cellFromEl(e.target); if(!cell) return;

  if(!S.first){                       // very first click
    S.first=cell; S.goal=cell; S.start=null;
  }else if(!S.goal||!S.start){        // selecting second cell
    const second=cell;
    const area1=S.first.r*S.first.c;
    const area2=second.r*second.c;
    if(area1===area2) return;         // ignore identical area
    if(area1>area2){ S.goal=S.first; S.start=second;}
    else           { S.goal=second;  S.start=S.first;}
    S.solution=genSolution();
    S.drawn=[];
  }else{                              // both chosen → start over with new first
    S.first=cell; S.goal=cell; S.start=null; S.solution=[]; S.drawn=[];
  }
  paint(); updateInfo(); updateSentenceTab(); updateButtons();
});

/* ─────────────────── drawing rectangles ───────────────── */
wrap.addEventListener('mousedown',e=>{
  if(!S.goal||!S.start) return;
  const cell=cellFromEl(e.target); if(!cell) return;
  S.dragging=true; S.dragStart=cell;
});
window.addEventListener('mousemove',e=>{
  if(!S.dragging) return;
  layer.querySelector('.preview')?.remove();
  const cell=cellFromEl(e.target); if(!cell) return;
  const ext=extentRect(S.dragStart.r,S.dragStart.c,cell.r,cell.c);
  addRect(ext,'preview');
});
window.addEventListener('mouseup',e=>{
  if(!S.dragging) return;
  layer.querySelector('.preview')?.remove();
  const cell=cellFromEl(e.target); if(cell){
    const candidate=canon({r1:S.dragStart.r,c1:S.dragStart.c,r2:cell.r,c2:cell.c});
    const idx=S.solution.findIndex(sol=>sameRect(sol,candidate));
    if(idx>-1 && !S.drawn.some(d=>sameRect(d,candidate))){
      S.drawn.push(candidate);
    }else{
      alert('That rectangle isn’t one of the required pieces.');
    }
  }
  S.dragging=false; S.dragStart=null;
  paint(); updateInfo(); updateSentenceTab(); updateButtons();
});

/* remove a user rectangle on click */
layer.addEventListener('click',e=>{
  const idx=e.target.dataset.idx;
  if(idx!==undefined){
    S.drawn.splice(+idx,1);
    paint(); updateInfo(); updateSentenceTab(); updateButtons();
  }
});

/* ─────────────────── Clear / Swap ─────────────────────── */
clearB.onclick = ()=>{
  Object.assign(S,{first:null,goal:null,start:null,solution:[],drawn:[]});
  paint();updateInfo();updateSentenceTab();updateButtons();
};
swapB.onclick = ()=>{
  if(!(S.goal&&S.start))return;
  [S.goal,S.start]=[S.start,S.goal];
  // ensure bigger area is goal again per rule
  if(S.start.r*S.start.c > S.goal.r*S.goal.c)
    [S.goal,S.start]=[S.start,S.goal];
  S.solution=genSolution(); S.drawn=[];
  paint();updateInfo();updateSentenceTab();updateButtons();
};

/* ───────────────────── tab switching ──────────────────── */
tabEls.forEach(tab=>{
  tab.onclick=()=>{
    tabEls.forEach(t=>t.classList.toggle('active',t===tab));
    const isSentence = tab.dataset.tab==='sentence';
    sentenceTab.style.display = isSentence?'block':'none';
    wrap.style.display        = isSentence?'none':'inline-block';
    updateSentenceTab();
  };
});

updateInfo();          // initial text
new ResizeObserver(paint).observe(wrap);
</script>
</body>
</html>
