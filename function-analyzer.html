<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Function Builder & Analyzer</title>
    <style>
        :root {
            --primary-color: #1565c0;
            --secondary-color: #2e7d32; /* Green */
            --danger-color: #d32f2f;  /* Red */
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #424242;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: var(--light-gray); color: var(--dark-gray); display: flex; justify-content: center; padding: 1rem; }
        .container { width: 100%; max-width: 1000px; margin: 0 auto; background-color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px; padding: 1.5rem; }
        h2 { font-size: 1.75rem; color: var(--primary-color); margin-bottom: 0.5rem; }
        p.info { color: #616161; margin-bottom: 1.5rem; }
        h3 { font-size: 1.25rem; color: var(--dark-gray); margin-top: 1.5rem; margin-bottom: 1rem; border-top: 1px solid var(--medium-gray); padding-top: 1.5rem;}
        
        .main-layout { display: grid; grid-template-columns: 300px 1fr; gap: 1.5rem; }
        .controls-panel { display: flex; flex-direction: column; gap: 1rem; }
        .control-group { display: flex; flex-direction: column; gap: 0.75rem; padding: 1rem; background-color: var(--light-gray); border-radius: 6px;}
        .piece-library { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
        
        label { font-size: 0.9rem; font-weight: 600; color: #616161; }
        select, button { border: 1px solid var(--medium-gray); border-radius: 4px; padding: 10px; font-size: 1rem; width: 100%; cursor: pointer; background-color: white; transition: background-color 0.2s, color 0.2s, border-color 0.2s; }
        button:hover { background-color: #e3f2fd; }
        button.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); font-weight: bold; }
        .danger-button { background-color: var(--danger-color); color: white; }
        .danger-button:hover { background-color: #c62828; }
        .secondary-button { background-color: var(--secondary-color); color: white; }
        .secondary-button:hover { background-color: #1b5e20; }
        
        .canvas-wrapper { position: relative; width: 100%; aspect-ratio: 1/1; user-select: none; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #grid-canvas { background-color: white; border: 1px solid var(--medium-gray); border-radius: 4px; z-index: 1;}
        #main-canvas { z-index: 5; cursor: crosshair; }
        #vlt-line { position: absolute; top: 0; bottom: 0; width: 2px; background-color: var(--danger-color); z-index: 20; display: none; }

        #analysis-results { margin-top: 1rem; padding: 1rem; background-color: var(--light-gray); border-radius: 4px; font-size: 0.95rem; text-align: left; line-height: 1.7; white-space: pre-wrap; font-family: monospace; min-height: 100px;}
        
        @media (max-width: 800px) { .main-layout { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
<div class="container">
    <h2>Interactive Function Builder</h2>
    <p class="info">Construct your own piecewise function by selecting pieces from the library and placing them on the grid. Then, run a complete analysis of the function you built.</p>
    
    <div class="main-layout">
        <div class="controls-panel">
            <div class="control-group">
                <label>1. Select a Tool:</label>
                <div class="piece-library">
                    <button class="tool-btn" data-tool="line">Draw Line</button>
                    <button class="tool-btn" data-tool="curve">Draw Curve</button>
                </div>
            </div>
            <div class="control-group">
                <label>2. Load an Example:</label>
                <select id="example-select">
                     <option value="">-- Clear Canvas --</option>
                </select>
            </div>
            <div class="control-group">
                <label>3. Analyze & Manage:</label>
                <button id="analyze-btn" class="secondary-button">Analyze Graph</button>
                <button id="clear-btn" class="danger-button" style="margin-top: 0.5rem;">Clear Canvas</button>
            </div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="grid-canvas"></canvas>
            <canvas id="main-canvas"></canvas>
            <div id="vlt-line"></div>
        </div>
    </div>
    
    <h3>Analysis Results</h3>
    <div id="analysis-results"><p>Build a function and click "Analyze Graph".</p></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE & CONFIG ---
    let state = {
        tool: 'line', 
        placingState: 'idle', // idle, placing_end, adjusting_curve
        startPoint: null,
        pieces: [], // { type, p1, p2, (optional) cp }
        analysis: null
    };

    const EXAMPLES = {
        "Simple Function": { id: "simple_func" },
        "Function with Jumps": { id: "jump_func" },
        "Function with Cusp": { id: "cusp_func" },
        "Non-Function (Vertical)": { id: "vertical_line" },
    };

    // --- DOM REFERENCES ---
    const canvas = document.getElementById('main-canvas');
    const gridCanvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const gridCtx = gridCanvas.getContext('2d');
    const toolButtons = document.querySelectorAll('.tool-btn');
    const exampleSelect = document.getElementById('example-select');
    const clearBtn = document.getElementById('clear-btn');
    const analyzeBtn = document.getElementById('analyze-btn');
    const vltLine = document.getElementById('vlt-line');
    const analysisResultsEl = document.getElementById('analysis-results');

    // Coordinate conversion helpers
    const toScreen = (p) => ({ x: (p.x + 10)/20 * canvas.clientWidth, y: (1 - (p.y + 10)/20) * canvas.clientHeight });
    const fromScreen = (coords) => ({ x: (coords.x / canvas.clientWidth)*20-10, y: (1 - coords.y/canvas.clientHeight)*20-10 });

    // --- INITIALIZATION ---
    function initialize() {
        Object.keys(EXAMPLES).forEach(name => exampleSelect.appendChild(new Option(name, EXAMPLES[name].id)));
        
        toolButtons.forEach(btn => btn.addEventListener('click', () => setTool(btn.dataset.tool)));
        clearBtn.addEventListener('click', clearCanvas);
        exampleSelect.addEventListener('change', loadExample);
        analyzeBtn.addEventListener('click', runAnalysis);
        
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        
        window.addEventListener('resize', resizeAndRedraw);
        setTool('line');
        resizeAndRedraw();
    }

    function resizeAndRedraw() {
        [canvas, gridCanvas].forEach(c => {
            const dpr = window.devicePixelRatio || 1;
            const rect = c.parentElement.getBoundingClientRect();
            if (rect.width > 0) {
                c.width = rect.width * dpr; c.height = rect.width * dpr;
                c.getContext('2d').scale(dpr, dpr);
            }
        });
        redraw();
    }
    
    function setTool(tool) {
        state.tool = tool;
        toolButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
        state.placingState = 'idle'; state.startPoint = null;
        redraw();
    }

    function redraw() {
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        gridCtx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        drawGrid();
        state.pieces.forEach(p => drawPiece(p));
        if(state.isPlacing && state.firstPoint) drawPoint(state.firstPoint, 'var(--primary-color)', 'var(--primary-color)');
    }

    function drawGrid() { /* ... unchanged ... */ }
    function drawPiece(piece) { /* ... unchanged ... */ }
    function drawPoint(p, fillColor, strokeColor) { /* ... unchanged ... */ }
    
    function handleMouseMove(e) {
        if (state.placingState !== 'placing_end' && state.placingState !== 'adjusting_curve') return;
        redraw();
        const p2 = fromScreen({x: e.offsetX, y: e.offsetY});
        
        if (state.placingState === 'placing_end') {
            const tempPiece = createPiece(state.tool, state.startPoint, p2);
            drawPiece(tempPiece);
        } else if (state.placingState === 'adjusting_curve') {
            const currentPiece = state.pieces[state.pieces.length - 1];
            currentPiece.cp = p2;
            drawPiece(currentPiece);
        }
    }
    
    function handleMouseDown(e) {
        const clickCoords = fromScreen({x: e.offsetX, y: e.offsetY});

        if (state.placingState === 'idle') {
            state.placingState = 'placing_end';
            state.startPoint = snapToPoint(clickCoords);
        } else if (state.placingState === 'placing_end') {
            const p2 = snapToPoint(clickCoords);
            const newPiece = createPiece(state.tool, state.startPoint, p2);
            state.pieces.push(newPiece);
            
            if (state.tool === 'curve') {
                state.placingState = 'adjusting_curve';
            } else {
                state.placingState = 'idle';
                state.startPoint = null;
            }
        } else if (state.placingState === 'adjusting_curve') {
            state.pieces[state.pieces.length - 1].cp = clickCoords;
            state.placingState = 'idle';
            state.startPoint = null;
        }
        redraw();
    }

    function snapToPoint(p) { /* ... unchanged ... */ }
    function createPiece(tool, p1, p2) { /* ... unchanged ... */ }
    function clearCanvas() { state.pieces = []; state.analysis = null; vltLine.style.display = 'none'; redraw(); analysisResultsEl.innerHTML = '<p>Canvas cleared.</p>'}
    
    function runAnalysis() {
        if (state.pieces.length === 0) {
            analysisResultsEl.textContent = 'Please build a function first.';
            return;
        }
        state.analysis = analyze(state.pieces);
        displayAnalysisResults();
        
        vltLine.style.display = 'none';
        if (!state.analysis.isFunction.result) {
            const failPos = toScreen({x: state.analysis.isFunction.x, y: 0});
            vltLine.style.left = `${failPos.x}px`;
            vltLine.style.display = 'block';
        }
    }

    function analyze(pieces) { /* ... Full analysis logic here ... */ return {}; }
    function displayAnalysisResults() { /* ... Full display logic here ... */ }

    // --- Full implementation of placeholder functions ---
    function drawGrid() {
        const w = gridCanvas.clientWidth, h = gridCanvas.clientHeight;
        gridCtx.strokeStyle = '#f0f0f0'; gridCtx.lineWidth = 1;
        for (let i = -10; i <= 10; i++) {
            const sx = toScreen({x:i, y:0}).x, sy = toScreen({x:0, y:i}).y;
            gridCtx.beginPath(); gridCtx.moveTo(sx, 0); gridCtx.lineTo(sx, h); gridCtx.stroke();
            gridCtx.beginPath(); gridCtx.moveTo(0, sy); gridCtx.lineTo(w, sy); gridCtx.stroke();
        }
        gridCtx.strokeStyle = '#e0e0e0'; gridCtx.lineWidth = 2;
        gridCtx.beginPath(); gridCtx.moveTo(w/2, 0); gridCtx.lineTo(w/2, h); gridCtx.stroke();
        gridCtx.beginPath(); gridCtx.moveTo(0, h/2); gridCtx.lineTo(w, h/2); gridCtx.stroke();
    }

    function drawPiece(piece) {
        ctx.strokeStyle = 'var(--primary-color)'; ctx.lineWidth = 3; ctx.lineCap = 'round';
        ctx.beginPath();
        const p1 = toScreen(piece.p1), p2 = toScreen(piece.p2);
        ctx.moveTo(p1.x, p1.y);
        if (piece.type === 'line') {
            ctx.lineTo(p2.x, p2.y);
        } else if (piece.type === 'curve') {
            const cp = toScreen(piece.cp);
            ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
            // Draw handle for adjusting
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(cp.x, cp.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            ctx.setLineDash([]);
        }
        ctx.stroke();
        if (piece.startType === 'open') drawPoint(piece.p1, 'white', 'var(--primary-color)'); else drawPoint(piece.p1, 'var(--primary-color)', 'var(--primary-color)');
        if (piece.endType === 'open') drawPoint(piece.p2, 'white', 'var(--primary-color)'); else drawPoint(piece.p2, 'var(--primary-color)', 'var(--primary-color)');
    }
    
    function drawPoint(p, fillColor, strokeColor) { if(!p) return; const {x, y} = toScreen(p); ctx.fillStyle = fillColor; ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(x, y, 5, 0, 2*Math.PI); ctx.fill(); ctx.stroke(); }

    function snapToPoint(p) {
        if (state.pieces.length > 0) {
            const lastPiece = state.pieces[state.pieces.length - 1];
            if (Math.hypot(p.x-lastPiece.p2.x, p.y-lastPiece.p2.y) < 1) return lastPiece.p2;
        }
        return {x: Math.round(p.x), y: Math.round(p.y)};
    }
    
    function createPiece(tool, p1, p2) {
        if (p1.x === p2.x && p1.y === p2.y) return null;
        const piece = { p1, p2, type: tool, startType: 'closed', endType: 'closed' };
        if (tool === 'curve') {
            piece.cp = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }
        return piece;
    }
    
    function analyze(pieces) {
        // This is a simplified analysis based on precise pieces
        if (pieces.length === 0) return null;
        const allPoints = pieces.map(p => [p.p1, p.p2]).flat();
        let domain = [Infinity, -Infinity], range = [Infinity, -Infinity];
        pieces.forEach(({p1, p2, cp}) => {
            domain[0] = Math.min(domain[0], p1.x, p2.x); domain[1] = Math.max(domain[1], p1.x, p2.x);
            const y_coords = [p1.y, p2.y];
            if (cp) y_coords.push(cp.y); // A simple proxy for curve range
            range[0] = Math.min(range[0], ...y_coords); range[1] = Math.max(range[1], ...y_coords);
        });
        
        let isFunc = true, failX = null;
        for(let i=0; i<pieces.length; i++) {
            for(let j=i; j<pieces.length; j++) {
                const p1 = pieces[i], p2 = pieces[j];
                const x_overlap = Math.max(p1.p1.x, p2.p1.x) < Math.min(p1.p2.x, p2.p2.x);
                if (i !== j && x_overlap) { isFunc = false; failX = Math.max(p1.p1.x, p2.p1.x); break;}
            }
            if(!isFunc) break;
        }

        return { isFunction: {result: isFunc, x: failX}, domain, range };
    }

    function displayAnalysisResults() {
        if (!state.analysis) { analysisResultsEl.innerHTML = "<p>Could not analyze the graph. Please try building a simpler function.</p>"; return; }
        const { isFunction, domain, range } = state.analysis;
        const format = (arr, label) => `<p>${label}: <strong>[${arr[0].toFixed(1)}, ${arr[1].toFixed(1)}]</strong></p>`;
        let html = `<p><strong>Function?</strong>: ${isFunction.result ? 'Yes ✅' : `No ❌ (Fails Vertical Line Test near x=${isFunction.x.toFixed(2)})`}</p>`;
        html += format(domain, "Domain");
        html += format(range, "Range");
        analysisResultsEl.innerHTML = html;
    }

    function loadExample() {
        const type = exampleSelect.value;
        if (!type) { clearCanvas(); return; }
        let pieces = [];
        switch(type) {
            case 'v_shape':
                pieces = [{type:'line', p1:{x:-5, y:5}, p2:{x:0, y:0}}, {type:'line', p1:{x:0, y:0}, p2:{x:5, y:5}}];
                break;
            case 'jump_func':
                pieces = [
                    {type:'line', p1:{x:-5, y:2}, p2:{x:0, y:2}, endType:'open'},
                    {type:'line', p1:{x:0, y:-2}, p2:{x:5, y:-2}, startType:'closed'}
                ];
                break;
            case 'vertical_line':
                pieces = [{type:'line', p1:{x:2, y:-4}, p2:{x:2, y:4}}];
                break;
        }
        state.pieces = pieces;
        redraw();
        runAnalysis();
    }
    
    initialize();
});
</script>
</body>
</html>
