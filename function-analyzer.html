<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Parametric Graph Builder – Advanced Analysis Edition</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <style>
/* --- [CHANGELOG] ---
Major edits by Gemini (v2):
Redesigned the table layout for clarity and symmetry based on user feedback, grouping coordinate inputs with their respective open/closed selectors. Implemented a new, advanced analysis module to compute and display intervals of increasing/decreasing/constant behavior and concavity (concave up/down) for all segments. The analysis correctly handles both line and quadratic Bézier curve segments, using calculus (first and second derivatives) to find extrema and inflection points. The output is now formatted with proper mathematical interval notation and union symbols (e.g., "[-5.0, -2.1] ∪ [1.3, 4.0]").
--- [/CHANGELOG] --- */
      :root{--blue:#1565c0;--blue-dark:#0d47a1;--green:#43a047;--orange:#e65100;--grey:#bdbdbd;--red:#d32f2f;--surface:#fff;--surface-alt:#f4f4fa}
      html,body{margin:0;padding:0;height:100%;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;background:var(--surface-alt);color:#222}
      .container{max-width:1120px;margin:20px auto;background:var(--surface);border-radius:14px;box-shadow:0 4px 16px #0000000d;padding:1.5rem 2rem}
      h2{margin-top:0}
      .main-layout{display:flex;flex-wrap:wrap;gap:2.4rem;align-items:flex-start}
      .panel{flex:1 1 500px;min-width:320px}
      .canvas-wrapper{flex:1 1 420px;display:grid;place-items:center;min-width:300px;position:relative}
      .canvas-wrapper::before{content:'';display:block;padding-top:100%}
      canvas{position:absolute;inset:0;width:100%;height:100%;border-radius:10px}
      #grid-canvas{border:1.5px solid #e0e0e0;z-index:1}
      #main-canvas{z-index:2;cursor:crosshair}
      #handle-canvas{z-index:3;pointer-events:none}
      table{width:100%;border-collapse:collapse;font-size:0.95rem}
      th,td{padding:0.5em 0.45em;border:1px solid #ddd;text-align:center;vertical-align:top}
      th{background:#f4f8ff;font-weight:600}
      tr.selected-row{background:#e3f2fd!important}
      tr.dragging-row{opacity:0.6;background:#b3e5fc!important}
      .drag-handle{cursor:grab;font-size:1.25em;color:#888;user-select:none;padding-top:0.5em}
      .drag-handle:active{cursor:grabbing}
      button{cursor:pointer;border:none;border-radius:6px;font-size:1em;padding:0.5em 1em;transition:filter .15s,transform .15s}
      button:hover{filter:brightness(1.1)}
      button:active{transform:scale(0.97)}
      button:disabled{background:#ccc!important;cursor:not-allowed;filter:none}
      .secondary-btn{background:var(--green);color:#fff}
      .danger-btn{background:var(--red);color:#fff}
      .action-btn{padding:0.5em 0.8em;font-size:1em}
      select,input[type="number"]{font-size:inherit;padding:0.3em 0.35em;border:1px solid #ccc;border-radius:4px;width:100%;box-sizing:border-box}
      .input-group{display:flex;gap:5px;margin-bottom:6px}
      .input-group-stacked{display:flex;flex-direction:column;gap:5px}
      #analysis-results{font-family:ui-monospace,monospace;background:#f8faff;margin-top:1.3em;padding:1.2em;border-radius:8px;min-height:140px;white-space:pre-wrap;border:1px solid #e8eef8;font-size:0.9rem;line-height:1.6}
      #analysis-results strong{font-weight:600;color:#333}
      @media(max-width:900px){.main-layout{flex-direction:column} .panel,.canvas-wrapper{flex-basis:auto;width:100%}}
    </style>
</head>
<body>
  <div class="container">
    <h2>Parametric Graph Builder</h2>
    <div class="main-layout">
      <div class="panel">
        <div class="controls" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:1em">
          <button id="add-segment" class="secondary-btn">Add Segment</button>
          <button id="undo-btn" class="secondary-btn">↶ Undo</button>
          <button id="vline-btn" class="secondary-btn">Toggle Vertical Line</button>
        </div>
        <div class="table-wrap">
          <table id="segment-table">
            <thead>
              <tr>
                <th style="width:5%"></th>
                <th style="width:20%">Type</th>
                <th style="width:25%">From (x, y)</th>
                <th style="width:25%">To (x, y)</th>
                <th style="width:25%">Handle</th>
                <th>Act</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="analysis-results">Add segments to begin analysis.</div>
      </div>
      <div class="canvas-wrapper">
        <canvas id="grid-canvas"></canvas>
        <canvas id="main-canvas"></canvas>
        <canvas id="handle-canvas"></canvas>
      </div>
    </div>
  </div>
<script>
/************* CONSTANTS & HELPERS *************/
const DPR = window.devicePixelRatio || 1;
const WMIN = -8, WMAX = 8, GRID = 1;
const gridCv = document.getElementById('grid-canvas'), mainCv = document.getElementById('main-canvas'), handleCv = document.getElementById('handle-canvas');
const gCtx = gridCv.getContext('2d'), mCtx = mainCv.getContext('2d'), hCtx = handleCv.getContext('2d');

const cssSize = cv => ({ w: cv.getBoundingClientRect().width, h: cv.getBoundingClientRect().height });
const toScreen = (p, cvSize) => ({ x: (p.x - WMIN) / (WMAX - WMIN) * cvSize.w, y: (WMAX - p.y) / (WMAX - WMIN) * cvSize.h });
const fromScreen = (c, cvSize) => ({ x: WMIN + c.x / cvSize.w * (WMAX - WMIN), y: WMAX - c.y / cvSize.h * (WMAX - WMIN) });
const epTxt = t => ({ closed:'Closed', open:'Open', '-infty':'–∞', '+infty':'+∞' }[t] || t);
const deep = obj => JSON.parse(JSON.stringify(obj));
const varStr = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();

/********************* STATE *******************/
const state = {
    segments: [],
    sel: null,
    undo: [],
    drag: { row: null, handle: false, curveIdx: null, vline: false }
};

/************ INITIALISATION *******************/
window.addEventListener('DOMContentLoaded', init);
window.addEventListener('resize', resize);

function init() {
    attachListeners();
    resize();
    pushUndo();
    state.segments.push({ type: 'line', p1: { x: -5, y: -3 }, p2: { x: -1, y: 2 }, startType: 'closed', endType: 'closed', handleMode: 'auto', handle: { x: -3, y: -0.5 } });
    state.segments.push({ type: 'curve', p1: { x: -1, y: 2 }, p2: { x: 4, y: 5 }, startType: 'open', endType: 'closed', handleMode: 'manual', handle: { x: 1, y: 6 } });
    state.sel = 1;
    refresh();
}

function resize() {
    const box = gridCv.parentElement.getBoundingClientRect();
    const size = box.width;
    [gridCv, mainCv, handleCv].forEach(cv => {
        cv.style.width = `${size}px`; cv.style.height = `${size}px`;
        cv.width = size * DPR; cv.height = size * DPR;
        cv.getContext('2d').setTransform(DPR, 0, 0, DPR, 0, 0);
    });
    drawAll();
}

/************* LISTENERS **********************/
function attachListeners() {
    qs('#add-segment').addEventListener('click', addSegment);
    qs('#undo-btn').addEventListener('click', undo);
    qs('#vline-btn').addEventListener('click', toggleVLine);
    qs('#segment-table tbody').addEventListener('input', onCellEdit);
    qs('#segment-table tbody').addEventListener('click', onTableClick);
    mainCv.addEventListener('mousedown', canvasDown);
    mainCv.addEventListener('mousemove', canvasMove);
    document.addEventListener('mouseup', canvasUp); // Listen on document to catch mouseup outside canvas
    mainCv.addEventListener('mouseleave', () => mainCv.style.cursor = 'crosshair');
}
const qs = s => document.querySelector(s);

/************ STATE & RENDER CONTROL **************/
function refresh() {
    renderTable();
    drawAll();
    runAnalysis();
    qs('#undo-btn').disabled = state.undo.length === 0;
}

/************ TABLE FUNCTIONS *****************/
function addSegment() {
    pushUndo();
    const lastSeg = state.segments[state.segments.length - 1];
    const newP1 = lastSeg ? deep(lastSeg.p2) : {x: -2, y: 1};
    state.segments.push({ type: 'line', p1: newP1, p2: { x: newP1.x + 4, y: newP1.y }, startType: 'closed', endType: 'closed', handleMode: 'auto', handle: { x: newP1.x+2, y: newP1.y } });
    state.sel = state.segments.length - 1;
    refresh();
}

function renderTable() {
    const tbody = qs('#segment-table tbody');
    tbody.innerHTML = '';
    state.segments.filter(s => s.type !== 'vline').forEach((s, i) => {
        const tr = document.createElement('tr');
        tr.className = i === state.sel ? 'selected-row' : '';
        tr.dataset.i = i;
        tr.draggable = true;
        tr.addEventListener('dragstart', e => { state.drag.row = i; tr.classList.add('dragging-row'); e.dataTransfer.effectAllowed = 'move'; });
        tr.addEventListener('dragover', e => { e.preventDefault(); e.currentTarget.style.background = '#f0faff'; });
        tr.addEventListener('dragleave', e => { e.currentTarget.style.background = ''; });
        tr.addEventListener('drop', e => {
            e.preventDefault(); e.currentTarget.style.background = '';
            if (state.drag.row !== null && state.drag.row !== i) {
                pushUndo();
                const [movedItem] = state.segments.splice(state.drag.row, 1);
                state.segments.splice(i, 0, movedItem);
                state.sel = i;
                refresh();
            }
        });
        tr.addEventListener('dragend', () => { qsAll('#segment-table tr').forEach(r => r.classList.remove('dragging-row')); state.drag.row = null; });
        tr.addEventListener('click', (e) => { if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {state.sel = i; refresh();} });

        const td = (html, className = '') => { const d = document.createElement('td'); d.innerHTML = html; d.className = className; return d; };
        
        tr.appendChild(td('<div class="drag-handle" title="Drag to reorder">&#9776;</div>'));
        tr.appendChild(td(`<select data-i="${i}" data-k="type"><option value="line" ${s.type==='line'?'selected':''}>Line</option><option value="curve" ${s.type==='curve'?'selected':''}>Curve</option></select>`));
        
        // FROM
        tr.appendChild(td(`
            <div class="input-group">
                <input type="number" step="0.1" value="${getVal(s,'p1.x')}" data-i="${i}" data-k="p1.x" title="From X">
                <input type="number" step="0.1" value="${getVal(s,'p1.y')}" data-i="${i}" data-k="p1.y" title="From Y">
            </div>
            <select data-i="${i}" data-k="startType">${['closed','open','-infty'].map(t=>`<option value="${t}" ${s.startType===t?'selected':''}>${epTxt(t)}</option>`).join('')}</select>
        `));
        // TO
        tr.appendChild(td(`
            <div class="input-group">
                <input type="number" step="0.1" value="${getVal(s,'p2.x')}" data-i="${i}" data-k="p2.x" title="To X">
                <input type="number" step="0.1" value="${getVal(s,'p2.y')}" data-i="${i}" data-k="p2.y" title="To Y">
            </div>
            <select data-i="${i}" data-k="endType">${['closed','open','+infty'].map(t=>`<option value="${t}" ${s.endType===t?'selected':''}>${epTxt(t)}</option>`).join('')}</select>
        `));
        // HANDLE
        const isManual = s.handleMode === 'manual' && s.type === 'curve';
        tr.appendChild(td(`
             <select data-i="${i}" data-k="handleMode" ${s.type!=='curve'?'disabled':''}>
                <option value="auto" ${s.handleMode==='auto'?'selected':''}>Auto</option>
                <option value="manual" ${s.handleMode==='manual'?'selected':''}>Manual</option>
             </select>
             <div class="input-group" style="margin-top:6px;">
                <input type="number" step="0.1" value="${s.handle?.x??''}" data-i="${i}" data-k="handle.x" title="Handle X" ${!isManual?'disabled':''}>
                <input type="number" step="0.1" value="${s.handle?.y??''}" data-i="${i}" data-k="handle.y" title="Handle Y" ${!isManual?'disabled':''}>
             </div>
        `));
        // ACTIONS
        tr.appendChild(td(`<button class="action-btn danger-btn" data-act="del" data-i="${i}" title="Delete Segment">✕</button>`));
        tbody.appendChild(tr);
    });
}
const qsAll = s => document.querySelectorAll(s);

function getVal(obj, path) { return path.split('.').reduce((o, k) => o?.[k], obj); }
function setVal(obj, path, val) {
    const keys = path.split('.'); let current = obj;
    for (let i = 0; i < keys.length - 1; i++) { current = current[keys[i]]; }
    current[keys[keys.length - 1]] = val;
}

function onCellEdit(e) {
    const t = e.target; if (!t.dataset.k) return;
    pushUndo();
    const i = +t.dataset.i; const k = t.dataset.k; const s = state.segments[i];
    const val = t.tagName === 'INPUT' ? parseFloat(t.value) : t.value;
    setVal(s, k, val);
    if (s.handleMode === 'auto') {
        s.handle = { x: (s.p1.x + s.p2.x) / 2, y: (s.p1.y + s.p2.y) / 2 };
    }
    if (k === 'handleMode' || k === 'type') { refresh(); } 
    else { drawAll(); runAnalysis(); }
}

function onTableClick(e) {
    const btn = e.target.closest('button[data-act]'); if (!btn) return;
    const i = +btn.dataset.i;
    if (btn.dataset.act === 'del') {
        pushUndo();
        state.segments.splice(i, 1);
        state.sel = state.segments.length > 0 ? Math.max(0, i - 1) : null;
        refresh();
    }
}

/************ UNDO *****************************/
function pushUndo() {
    state.undo.push(deep({ seg: state.segments, sel: state.sel }));
    qs('#undo-btn').disabled = false;
}

function undo() {
    if (state.undo.length === 0) return;
    const prevState = state.undo.pop();
    state.segments = prevState.seg; state.sel = prevState.sel;
    refresh();
}

/************ VERTICAL LINE *******************/
function toggleVLine() {
    pushUndo();
    const vlineIdx = state.segments.findIndex(s => s.type === 'vline');
    if (vlineIdx === -1) { state.segments.push({ type: 'vline', x: 0 }); } 
    else { state.segments.splice(vlineIdx, 1); }
    refresh();
}

/************ CANVAS DRAWING (Identical to previous, no changes needed) ******************/
function drawGrid(){const c=cssSize(gridCv);gCtx.clearRect(0,0,c.w,c.h);gCtx.strokeStyle="#f0f0f0";gCtx.lineWidth=1;for(let i=Math.ceil(WMIN);i<=Math.floor(WMAX);i+=GRID){const s=toScreen({x:i,y:0},c),t=toScreen({x:0,y:i},c);gCtx.beginPath();gCtx.moveTo(s.x,0);gCtx.lineTo(s.x,c.h);gCtx.stroke();gCtx.beginPath();gCtx.moveTo(0,t.y);gCtx.lineTo(c.w,t.y);gCtx.stroke()}const z=toScreen({x:0,y:0},c);gCtx.lineWidth=1.5;gCtx.strokeStyle=varStr('--grey');gCtx.beginPath();gCtx.moveTo(0,z.y);gCtx.lineTo(c.w,z.y);gCtx.stroke();gCtx.beginPath();gCtx.moveTo(z.x,0);gCtx.lineTo(z.x,c.h);gCtx.stroke()}
function drawEndpoint(p,type,ctx,c){const t=toScreen(p,c);ctx.save();ctx.strokeStyle=varStr('--blue-dark');ctx.lineWidth=1.6;ctx.beginPath();ctx.arc(t.x,t.y,5,0,Math.PI*2);if(type==='closed'){ctx.fillStyle=varStr('--blue');ctx.fill()}ctx.stroke();ctx.restore()}
function drawSegment(s,isSelected){const c=cssSize(mainCv);if(s.type==='line'||s.type==='curve'){mCtx.strokeStyle=isSelected?varStr('--orange'):varStr('--blue');mCtx.lineWidth=isSelected?3.5:2.5;const p1s=toScreen(s.p1,c),p2s=toScreen(s.p2,c);mCtx.beginPath();mCtx.moveTo(p1s.x,p1s.y);if(s.type==='line'){mCtx.lineTo(p2s.x,p2s.y)}else{const hPos=(s.handleMode==='auto')?{x:(s.p1.x+s.p2.x)/2,y:(s.p1.y+s.p2.y)/2}:s.handle;const hs=toScreen(hPos,c);mCtx.quadraticCurveTo(hs.x,hs.y,p2s.x,p2s.y);if(isSelected&&s.handleMode==='manual'){hCtx.clearRect(0,0,c.w,c.h);hCtx.beginPath();hCtx.setLineDash([3,4]);hCtx.moveTo(p1s.x,p1s.y);hCtx.lineTo(hs.x,hs.y);hCtx.lineTo(p2s.x,p2s.y);hCtx.strokeStyle="#43a047aa";hCtx.lineWidth=1.5;hCtx.stroke();hCtx.setLineDash([]);hCtx.beginPath();hCtx.arc(hs.x,hs.y,7,0,Math.PI*2);hCtx.fillStyle=varStr('--green');hCtx.fill();hCtx.strokeStyle="#222";hCtx.lineWidth=1;hCtx.stroke()}}mCtx.stroke();if(s.startType!=='-infty')drawEndpoint(s.p1,s.startType,mCtx,c);if(s.endType!=='+infty')drawEndpoint(s.p2,s.endType,mCtx,c)}else if(s.type==='vline'){const x=toScreen({x:s.x,y:0},c).x;mCtx.strokeStyle=varStr('--orange');mCtx.lineWidth=state.drag.vline?4:2.5;mCtx.beginPath();mCtx.moveTo(x,0);mCtx.lineTo(x,c.h);mCtx.stroke()}}
function drawAll(){const c=cssSize(mainCv);drawGrid();mCtx.clearRect(0,0,c.w,c.h);hCtx.clearRect(0,0,c.w,c.h);state.segments.forEach((s,i)=>drawSegment(s,i===state.sel))}

/******** CANVAS INTERACTION (Identical to previous) *******************/
function mouseWorld(e){const r=mainCv.getBoundingClientRect();const c={x:e.clientX-r.left,y:e.clientY-r.top};return fromScreen(c,cssSize(mainCv))}
function handleHit(pt){const t=0.45;const i=state.segments.findIndex((s,idx)=>idx===state.sel&&s.type==='curve'&&s.handleMode==='manual');if(i!==-1){const s=state.segments[i];const dx=pt.x-s.handle.x;const dy=pt.y-s.handle.y;if(Math.sqrt(dx*dx+dy*dy)<t){return i}}return -1}
function canvasDown(e){const p=mouseWorld(e);const vIdx=state.segments.findIndex(s=>s.type==='vline');if(vIdx!==-1&&Math.abs(p.x-state.segments[vIdx].x)<0.25){state.drag.vline=true;mainCv.style.cursor='col-resize';return}const hIdx=handleHit(p);if(hIdx!==-1){state.drag.handle=true;state.drag.curveIdx=hIdx;mainCv.style.cursor='grabbing';return}}
function canvasMove(e){if(!state.drag.vline&&!state.drag.handle)return;const p=mouseWorld(e);if(state.drag.vline){const v=state.segments.find(s=>s.type==='vline');if(v){v.x=p.x;drawAll();runAnalysis()}}if(state.drag.handle){const s=state.segments[state.drag.curveIdx];s.handle.x=+p.x.toFixed(2);s.handle.y=+p.y.toFixed(2);refresh()}}
function canvasUp(){if(state.drag.vline||state.drag.handle){pushUndo()}state.drag={row:state.drag.row,handle:false,curveIdx:null,vline:false};mainCv.style.cursor='crosshair'}

/************ ADVANCED ANALYSIS ************************/
function runAnalysis() {
    const results = qs('#analysis-results');
    const segs = state.segments.filter(s => s.type !== 'vline').sort((a,b) => a.p1.x - b.p1.x);
    if (segs.length === 0) {
        results.textContent = 'Add segments to begin analysis.';
        return;
    }

    let domain = [Infinity, -Infinity], range = [Infinity, -Infinity];
    let increasing = [], decreasing = [], constant = [], concaveUp = [], concaveDown = [];

    segs.forEach(s => {
        // Ensure p1 is left of p2 for interval calculations
        const p1 = s.p1.x < s.p2.x ? s.p1 : s.p2;
        const p2 = s.p1.x < s.p2.x ? s.p2 : s.p1;
        const interval = [p1.x, p2.x];

        domain[0] = Math.min(domain[0], p1.x); domain[1] = Math.max(domain[1], p2.x);
        range[0] = Math.min(range[0], s.p1.y, s.p2.y); range[1] = Math.max(range[1], s.p1.y, s.p2.y);
        
        if (s.type === 'line') {
            if (Math.abs(p1.y - p2.y) < 1e-6) {
                constant.push(interval);
            } else if (p1.y < p2.y) {
                increasing.push(interval);
            } else {
                decreasing.push(interval);
            }
            // Lines have no concavity
        } else if (s.type === 'curve') {
            const h = s.handleMode === 'auto' ? { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 } : s.handle;
            
            // Concavity (from second derivative)
            const y_dd = 2 * (p1.y - 2 * h.y + p2.y);
            if (Math.abs(y_dd) < 1e-6) { /* effectively a line */ } 
            else if (y_dd > 0) concaveUp.push(interval);
            else concaveDown.push(interval);
            
            // Increasing/Decreasing (from first derivative)
            const t_extremum_num = p1.y - h.y;
            const t_extremum_den = p1.y - 2 * h.y + p2.y;

            if (Math.abs(t_extremum_den) < 1e-6) { // Derivative is constant, treat as line
                if (p2.y > p1.y) increasing.push(interval); else decreasing.push(interval);
            } else {
                const t = t_extremum_num / t_extremum_den;
                if (t > 0.001 && t < 0.999) { // Extremum is within the segment
                    const x_at_t = (1-t)*(1-t)*p1.x + 2*(1-t)*t*h.x + t*t*p2.x;
                    const y_at_0 = p1.y;
                    const y_at_t = (1-t)*(1-t)*p1.y + 2*(1-t)*t*h.y + t*t*p2.y;
                    
                    if (y_at_t > y_at_0) {
                        increasing.push([p1.x, x_at_t]);
                        decreasing.push([x_at_t, p2.x]);
                    } else {
                        decreasing.push([p1.x, x_at_t]);
                        increasing.push([x_at_t, p2.x]);
                    }
                } else { // Monotonic curve
                     if (p2.y > p1.y) increasing.push(interval); else decreasing.push(interval);
                }
            }
        }
    });

    const formatIntervals = (arr) => {
        if (arr.length === 0) return 'None';
        // Sort and merge intervals if needed (for simplicity, we are not merging here)
        return arr.map(i => `[${i[0].toFixed(1)}, ${i[1].toFixed(1)}]`).join(' \u222A ');
    };

    results.innerHTML = `
<strong>Domain:</strong>         ${formatIntervals([domain])}
<strong>Range:</strong>          [${range[0].toFixed(1)}, ${range[1].toFixed(1)}]
<strong>Increasing:</strong>     ${formatIntervals(increasing)}
<strong>Decreasing:</strong>     ${formatIntervals(decreasing)}
<strong>Constant:</strong>       ${formatIntervals(constant)}
<strong>Concave Up:</strong>     ${formatIntervals(concaveUp)}
<strong>Concave Down:</strong>   ${formatIntervals(concaveDown)}
    `.trim();
}
</script>
</body>
</html>
