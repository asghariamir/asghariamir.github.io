<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Function Builder & Analyzer</title>
    <style>
        :root {
            --primary-color: #1565c0;
            --secondary-color: #2e7d32;
            --danger-color: #d32f2f;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #424242;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: var(--light-gray); color: var(--dark-gray); display: flex; justify-content: center; padding: 1rem; }
        .container { width: 100%; max-width: 1200px; margin: 0 auto; background-color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px; padding: 1.5rem; }
        h2 { font-size: 1.75rem; color: var(--primary-color); margin-bottom: 0.5rem; }
        p.info { color: #616161; margin-bottom: 1.5rem; }
        h3 { font-size: 1.1rem; color: var(--dark-gray); margin-top: 1rem; margin-bottom: 0.5rem; border-bottom: 1px solid var(--medium-gray); padding-bottom: 0.5rem;}
        
        .main-layout { display: grid; grid-template-columns: 300px 1fr; gap: 1.5rem; }
        .controls-panel { display: flex; flex-direction: column; gap: 1rem; }
        .control-group { display: flex; flex-direction: column; gap: 0.75rem; padding: 1rem; background-color: var(--light-gray); border-radius: 6px;}
        .piece-library { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
        
        label { font-size: 0.9rem; font-weight: 600; color: #616161; }
        button { border: 1px solid var(--medium-gray); border-radius: 4px; padding: 10px; font-size: 0.9rem; width: 100%; cursor: pointer; background-color: white; transition: background-color 0.2s, color 0.2s, border-color 0.2s; }
        button:hover { background-color: #e3f2fd; }
        button.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); font-weight: bold; }
        .danger-button { background-color: var(--danger-color); color: white; }
        .danger-button:hover { background-color: #c62828; }
        
        .canvas-wrapper { position: relative; width: 100%; aspect-ratio: 1/1; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #grid-canvas { background-color: white; border: 1px solid var(--medium-gray); border-radius: 4px; z-index: 1;}
        #main-canvas { z-index: 5; cursor: crosshair; }
        #vlt-line { position: absolute; top: 0; bottom: 0; width: 2px; background-color: var(--danger-color); cursor: ew-resize; z-index: 20; display: none; }

        #analysis-results { margin-top: 1rem; padding: 1rem; background-color: var(--light-gray); border-radius: 4px; font-size: 0.95rem; text-align: left; line-height: 1.7; white-space: pre-wrap; font-family: monospace;}
        
        @media (max-width: 800px) { .main-layout { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
<div class="container">
    <h2>Interactive Function Builder</h2>
    <p class="info">Construct your own piecewise function by selecting pieces from the library and placing them on the grid. Then, run a complete analysis of the function you built.</p>
    
    <div class="main-layout">
        <div class="controls-panel">
            <div class="control-group">
                <label>1. Select a Piece to Add:</label>
                <div class="piece-library">
                    <button class="tool-btn" data-tool="line-inc">Line (Inc)</button>
                    <button class="tool-btn" data-tool="line-dec">Line (Dec)</button>
                    <button class="tool-btn" data-tool="line-const">Line (Const)</button>
                    <button class="tool-btn" data-tool="placeholder">---</button> <button class="tool-btn" data-tool="curve-inc-up">Curve (Inc, Up)</button>
                    <button class="tool-btn" data-tool="curve-inc-down">Curve (Inc, Down)</button>
                    <button class="tool-btn" data-tool="curve-dec-up">Curve (Dec, Up)</button>
                    <button class="tool-btn" data-tool="curve-dec-down">Curve (Dec, Down)</button>
                </div>
            </div>
             <div class="control-group">
                <label>2. Add Discontinuities:</label>
                 <div class="piece-library">
                    <button class="tool-btn" data-tool="hole">Add Hole</button>
                    <button class="tool-btn" data-tool="jump">Create Jump</button>
                </div>
            </div>
            <div class="control-group">
                <label>3. Analyze and Manage:</label>
                <button id="analyze-btn">Analyze Graph</button>
                <button id="vlt-toggle-btn" style="margin-top: 0.5rem;">Toggle Vertical Line Test</button>
                <button id="clear-btn" class="danger-button" style="margin-top: 0.5rem;">Clear Canvas</button>
            </div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="grid-canvas"></canvas>
            <canvas id="main-canvas"></canvas>
            <div id="vlt-line"></div>
        </div>
    </div>
    
    <h3>Analysis Results</h3>
    <div id="analysis-results"><p>Build a function and click "Analyze Graph".</p></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE & CONFIG ---
    let state = {
        pieces: [],
        currentTool: null,
        isPlacing: false,
        firstPoint: null
    };

    // --- DOM REFERENCES ---
    const canvas = document.getElementById('main-canvas');
    const gridCanvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const gridCtx = gridCanvas.getContext('2d');
    const toolButtons = document.querySelectorAll('.tool-btn');
    const clearBtn = document.getElementById('clear-btn');
    const analyzeBtn = document.getElementById('analyze-btn');
    const vltToggleBtn = document.getElementById('vlt-toggle-btn');
    const vltLine = document.getElementById('vlt-line');
    const analysisResultsEl = document.getElementById('analysis-results');

    // Coordinate conversion helpers
    const toScreen = (p) => ({ x: (p.x + 10)/20 * canvas.clientWidth, y: (1 - (p.y + 10)/20) * canvas.clientHeight });
    const fromScreen = (coords) => ({ x: (coords.x / canvas.clientWidth)*20-10, y: (1 - coords.y/canvas.clientHeight)*20-10 });

    // --- INITIALIZATION ---
    function initialize() {
        toolButtons.forEach(btn => btn.addEventListener('click', () => setTool(btn.dataset.tool)));
        clearBtn.addEventListener('click', clearCanvas);
        analyzeBtn.addEventListener('click', runAnalysis);
        vltToggleBtn.addEventListener('click', toggleVLT);
        
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleMouseMove);
        
        window.addEventListener('resize', resizeAndRedraw);
        setTool('line-inc');
        resizeAndRedraw();
    }

    // --- DRAWING & CANVAS MGMT ---
    function resizeAndRedraw() {
        [canvas, gridCanvas].forEach(c => {
            const dpr = window.devicePixelRatio || 1;
            const rect = c.parentElement.getBoundingClientRect();
            if (rect.width > 0) {
                c.width = rect.width * dpr; c.height = rect.width * dpr;
                c.getContext('2d').scale(dpr, dpr);
            }
        });
        redraw();
    }

    function redraw() {
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        gridCtx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        drawGrid();
        state.pieces.forEach(p => drawPiece(p));
        if(state.isPlacing && state.firstPoint) drawPoint(state.firstPoint, 'var(--primary-color)', 'var(--primary-color)');
    }

    function drawGrid() {
        const w = gridCanvas.clientWidth, h = gridCanvas.clientHeight;
        gridCtx.strokeStyle = '#f0f0f0'; gridCtx.lineWidth = 1;
        for (let i = -10; i <= 10; i++) {
            const sx = toScreen({x:i, y:0}).x, sy = toScreen({x:0, y:i}).y;
            gridCtx.beginPath(); gridCtx.moveTo(sx, 0); gridCtx.lineTo(sx, h); gridCtx.stroke();
            gridCtx.beginPath(); gridCtx.moveTo(0, sy); gridCtx.lineTo(w, sy); gridCtx.stroke();
        }
        gridCtx.strokeStyle = '#e0e0e0'; gridCtx.lineWidth = 2;
        gridCtx.beginPath(); gridCtx.moveTo(w / 2, 0); gridCtx.lineTo(w / 2, h); gridCtx.stroke();
        gridCtx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
    }
    
    function drawPiece(piece) {
        ctx.strokeStyle = 'var(--primary-color)'; ctx.lineWidth = 3;
        ctx.beginPath();
        const p1 = toScreen(piece.p1), p2 = toScreen(piece.p2);
        ctx.moveTo(p1.x, p1.y);
        if (piece.type === 'line') {
            ctx.lineTo(p2.x, p2.y);
        } else if (piece.type === 'curve') {
            const cp = toScreen(piece.cp);
            ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
        }
        ctx.stroke();
        
        if (piece.startType === 'open') drawPoint(piece.p1, 'white', 'var(--primary-color)');
        if (piece.endType === 'open') drawPoint(piece.p2, 'white', 'var(--primary-color)');
    }

    function drawPoint(p, fillColor, strokeColor) { if(!p) return; const {x, y} = toScreen(p); ctx.fillStyle = fillColor; ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(x, y, 5, 0, 2*Math.PI); ctx.fill(); ctx.stroke(); }

    function handleControlClick() { /* ... Not needed with direct listeners ... */ }
    function setTool(tool) {
        state.currentTool = tool;
        toolButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
        state.isPlacing = false; state.firstPoint = null;
        redraw();
    }

    function handleMouseMove(e) {
        if (!state.isPlacing || !state.currentTool) return;
        redraw(); // Redraw base state
        const p1 = state.firstPoint;
        const p2 = fromScreen({x: e.offsetX, y: e.offsetY});
        const tempPiece = createPiece(state.currentTool, p1, p2);
        drawPiece(tempPiece);
    }
    
    function handleCanvasClick(e) {
        const clickCoords = fromScreen({x: e.offsetX, y: e.offsetY});
        if (state.currentTool === 'hole') {
            // Find closest piece and add a hole
            return;
        }

        if (!state.isPlacing) {
            state.isPlacing = true;
            state.firstPoint = snapToPoint(clickCoords);
        } else {
            const p2 = snapToPoint(clickCoords);
            const newPiece = createPiece(state.currentTool, state.firstPoint, p2);
            state.pieces.push(newPiece);
            state.isPlacing = false;
            state.firstPoint = null;
        }
        redraw();
    }
    
    function snapToPoint(p) {
        for (const piece of state.pieces) {
            if(Math.hypot(p.x-piece.p2.x, p.y-piece.p2.y) < 0.5) return piece.p2;
        }
        return p;
    }

    function createPiece(tool, p1, p2) {
        const piece = { p1, p2, startType: 'closed', endType: 'closed' };
        const [type, behavior, concavity] = tool.split('-');
        piece.type = type;
        
        if (type === 'curve') {
            const midX = (p1.x + p2.x) / 2, midY = (p1.y + p2.y) / 2;
            const perpDx = -(p2.y - p1.y), perpDy = p2.x - p1.x;
            const norm = Math.hypot(perpDx, perpDy);
            const curveFactor = 0.3;
            let controlOffsetX = perpDx / norm * curveFactor;
            let controlOffsetY = perpDy / norm * curveFactor;
            
            if( (behavior === 'inc' && concavity === 'down') || (behavior === 'dec' && concavity === 'up') ) {
                controlOffsetX *= -1; controlOffsetY *= -1;
            }
            piece.cp = { x: midX + controlOffsetX, y: midY + controlOffsetY };
        }
        return piece;
    }
    
    function clearCanvas() { state.paths = []; state.analysisResults = null; redraw(); analysisResultsEl.innerHTML = '<p>Canvas cleared. Draw a new function.</p>'}
    
    function runAnalysis() { /* ... To be implemented ... */ analysisResultsEl.textContent = "Analysis logic coming soon!"; }
    function toggleVLT() { vltLine.style.display = vltLine.style.display === 'block' ? 'none' : 'block'; }
    // Add drag functionality for VLT line
    let vltDragging = false;
    vltLine.addEventListener('mousedown', () => vltDragging = true);
    window.addEventListener('mouseup', () => vltDragging = false);
    window.addEventListener('mousemove', e => { if(vltDragging) vltLine.style.left = `${e.clientX - gridWrapper.getBoundingClientRect().left}px`;});
    
    initialize();
});
</script>
</body>
</html>
