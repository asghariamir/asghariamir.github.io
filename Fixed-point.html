<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed-Point Iteration Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <style>
        :root {
            --primary-color: #1565c0;
            --secondary-color: #4caf50;
            --danger-color: #d32f2f;
            --convergent-color: #2e7d32;
            --divergent-color: #c62828;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #424242;
            --text-color: #212121;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--light-gray);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            padding: 1rem;
        }
        .container {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            padding: 1.5rem;
        }
        h2 { font-size: 1.75rem; color: var(--primary-color); margin-bottom: 0.5rem; text-align: center; }
        p.info { color: #616161; margin-bottom: 1.5rem; text-align: center; max-width: 700px; margin-left: auto; margin-right: auto;}
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem 1.5rem;
            padding: 1rem;
            background-color: var(--light-gray);
            border-radius: 6px;
            margin-bottom: 1.5rem;
        }
        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .button-group { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 1rem; }
        
        label { font-size: 0.9rem; font-weight: 600; color: #616161; }
        input[type="number"], select { border: 1px solid var(--medium-gray); border-radius: 4px; padding: 8px; font-size: 0.9rem; width: 100%; }
        
        button { background-color: var(--primary-color); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; transition: background-color 0.3s; }
        button:hover { background-color: #1976d2; }
        .secondary-button { background-color: #6c757d; }
        .secondary-button:hover { background-color: #5a6268; }
        .danger-button { background-color: var(--danger-color); }
        .danger-button:hover { background-color: #c62828; }
        button:disabled { background-color: #bdbdbd; cursor: not-allowed; }

        .plot-container { width: 100%; height: 450px; border: 1px solid var(--medium-gray); border-radius: 4px; margin-bottom: 1.5rem;}
        
        .log-container { max-height: 250px; overflow-y: auto; border: 1px solid var(--medium-gray); border-radius: 4px; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        th, td { border-bottom: 1px solid var(--medium-gray); padding: 8px; text-align: center; }
        thead th { background-color: var(--light-gray); font-weight: 600; position: sticky; top: 0; z-index: 1;}
        tbody tr:last-child td { border-bottom: none; }

        .info-box { padding: 0.75rem; border-radius: 4px; margin-bottom: 1.5rem; border: 1px solid; }
        .info-box.convergent { background-color: #e8f5e9; border-color: var(--convergent-color); color: var(--convergent-color); }
        .info-box.divergent { background-color: #ffebee; border-color: var(--divergent-color); color: var(--divergent-color); }
        .info-box strong { font-family: monospace; }
    </style>
</head>
<body>
<div class="container">
    <h2>Fixed-Point Iteration Visualizer</h2>
    <p class="info">This method finds a root of <strong>f(x) = 0</strong> by first rearranging the equation into the form <strong>x = g(x)</strong>. The solution is the "fixed point" where the graph of <strong>y = g(x)</strong> intersects the line <strong>y = x</strong>. The iteration x<sub>n+1</sub> = g(x<sub>n</sub>) is then used to find this point.</p>
    
    <div class="controls">
        <div class="control-group">
            <label for="problem-select">1. Choose a problem:</label>
            <select id="problem-select"></select>
        </div>
        <div class="control-group">
            <label for="g-select">2. Choose rearrangement g(x):</label>
            <select id="g-select"></select>
        </div>
        <div class="control-group">
            <label for="x0-input">3. Choose initial guess (x₀):</label>
            <input type="number" id="x0-input" value="1.5" step="0.1">
        </div>
    </div>
    
    <div id="convergence-info" class="info-box"></div>

    <div id="plot-container" class="plot-container"></div>
    
    <div class="button-group">
        <button id="start-btn">Start Iteration</button>
        <button id="step-btn" class="secondary-button" disabled>Step</button>
        <button id="animate-btn" class="secondary-button" disabled>Animate</button>
        <button id="reset-btn" class="danger-button">Reset</button>
    </div>

    <div class="log-container">
        <table id="log-table">
            <thead>
                <tr><th>Iteration (n)</th><th>xₙ</th></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- PROBLEMS & FUNCTIONS ---
    const PROBLEMS = {
        "x³ + 4x² - 10 = 0": {
            range: [-4, 2],
            fixedPoint: 1.36523,
            rearrangements: {
                "g(x) = x - x³ - 4x² + 10": { g: x => x - Math.pow(x,3) - 4*x*x + 10, g_prime: x => 1 - 3*x*x - 8*x },
                "g(x) = √(10/x - 4x)": { g: x => Math.sqrt(10/x - 4*x), g_prime: x => ( -10/(x*x) - 4 ) / (2*Math.sqrt(10/x - 4*x)) },
                "g(x) = 0.5 * √(10 - x³)": { g: x => 0.5 * Math.sqrt(10 - Math.pow(x,3)), g_prime: x => -0.75 * x*x / Math.sqrt(10 - x*x*x) },
                "g(x) = √(10 / (4+x))": { g: x => Math.sqrt(10 / (4+x)), g_prime: x => -0.5 * Math.sqrt(10) * Math.pow(x+4, -1.5) },
                "g(x) = x - (x³ + 4x² - 10)/(3x² + 8x)": { g: x => x - (x*x*x + 4*x*x - 10)/(3*x*x + 8*x), g_prime: null } // Newton's method
            }
        },
        "cos(x) - x = 0": {
            range: [-1, 2],
            fixedPoint: 0.739085,
            rearrangements: {
                "g(x) = cos(x)": { g: x => Math.cos(x), g_prime: x => -Math.sin(x) },
                "g(x) = x + cos(x) - x": { g: x => x + Math.cos(x) - x, g_prime: x => 1 - Math.sin(x) -1},
            }
        }
    };

    // --- STATE & DOM REFS ---
    let state = {
        g: null, g_prime: null, x_current: 0,
        iteration: 0, log: [], isRunning: false,
        animationInterval: null, fixedPoint: null
    };

    const problemSelect = document.getElementById('problem-select');
    const gSelect = document.getElementById('g-select');
    const x0Input = document.getElementById('x0-input');
    const startBtn = document.getElementById('start-btn');
    const stepBtn = document.getElementById('step-btn');
    const animateBtn = document.getElementById('animate-btn');
    const resetBtn = document.getElementById('reset-btn');
    const plotContainer = document.getElementById('plot-container');
    const logTableBody = document.querySelector('#log-table tbody');
    const convergenceInfo = document.getElementById('convergence-info');
    
    // --- CORE LOGIC ---
    function initialize() {
        Object.keys(PROBLEMS).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            problemSelect.appendChild(option);
        });
        
        problemSelect.addEventListener('change', populateGFunctions);
        gSelect.addEventListener('change', resetAndPlot);
        x0Input.addEventListener('change', resetAndPlot);
        
        startBtn.addEventListener('click', startIteration);
        stepBtn.addEventListener('click', performStep);
        animateBtn.addEventListener('click', toggleAnimation);
        resetBtn.addEventListener('click', resetAndPlot);
        
        populateGFunctions();
    }

    function populateGFunctions() {
        const problem = PROBLEMS[problemSelect.value];
        gSelect.innerHTML = '';
        Object.keys(problem.rearrangements).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            gSelect.appendChild(option);
        });
        resetAndPlot();
    }
    
    function resetAndPlot() {
        stopAnimation();
        state.isRunning = false;
        state.iteration = 0;
        state.log = [];
        state.x_current = parseFloat(x0Input.value);
        
        const problem = PROBLEMS[problemSelect.value];
        const g_data = problem.rearrangements[gSelect.value];
        state.g = g_data.g;
        state.g_prime = g_data.g_prime;
        state.fixedPoint = problem.fixedPoint;
        
        updateButtons();
        renderLog();
        plotFunction();
        checkConvergence();
    }

    function startIteration() {
        state.log = [{ iter: 0, x: state.x_current }];
        state.isRunning = true;
        renderLog();
        updateButtons();
        updatePlotAnnotations();
    }
    
    function performStep() {
        if (!state.isRunning) return false;
        const x_prev = state.x_current;
        const x_next = state.g(x_prev);
        
        state.iteration++;
        state.x_current = x_next;
        state.log.push({ iter: state.iteration, x: x_next });
        
        renderLog();
        updatePlotAnnotations();

        if (Math.abs(x_next - x_prev) < 1e-6 || state.iteration > 100) {
            stopAnimation();
            state.isRunning = false;
            updateButtons();
            return false;
        }
        return true;
    }

    function toggleAnimation() {
        if (state.animationInterval) stopAnimation();
        else {
            animateBtn.textContent = "Stop";
            animateBtn.classList.add('danger-button');
            state.animationInterval = setInterval(() => { if (!performStep()) stopAnimation(); }, 500);
        }
    }
    
    function stopAnimation() {
        clearInterval(state.animationInterval);
        state.animationInterval = null;
        animateBtn.textContent = "Animate";
        animateBtn.classList.remove('danger-button');
    }

    // --- RENDERING & PLOTTING ---
    function updateButtons() {
        startBtn.disabled = state.isRunning;
        stepBtn.disabled = !state.isRunning;
        animateBtn.disabled = !state.isRunning;
    }
    
    function renderLog() {
        logTableBody.innerHTML = '';
        state.log.forEach(row => {
            const tr = logTableBody.insertRow(0);
            tr.innerHTML = `<td>${row.iter}</td><td>${isNaN(row.x) ? 'Invalid' : row.x.toFixed(6)}</td>`;
        });
    }

    function checkConvergence() {
        if (state.g_prime) {
            const derivativeAtFixedPoint = state.g_prime(state.fixedPoint);
            const absDerivative = Math.abs(derivativeAtFixedPoint);
            if (absDerivative < 1) {
                convergenceInfo.className = 'info-box convergent';
                convergenceInfo.innerHTML = `Condition met: <strong>|g'(${state.fixedPoint.toFixed(2)})| &approx; ${absDerivative.toFixed(3)} < 1</strong>. Iteration should converge.`;
            } else {
                convergenceInfo.className = 'info-box divergent';
                convergenceInfo.innerHTML = `Condition NOT met: <strong>|g'(${state.fixedPoint.toFixed(2)})| &approx; ${absDerivative.toFixed(3)} &ge; 1</strong>. Iteration will likely diverge.`;
            }
        } else {
            convergenceInfo.className = 'info-box';
            convergenceInfo.innerHTML = "Convergence condition for this g(x) is more complex (e.g., Newton's method).";
        }
    }

    function plotFunction() {
        const problem = PROBLEMS[problemSelect.value];
        const range = problem.range;
        const xValues = [], gValues = [];
        const stepSize = (range[1] - range[0]) / 400;

        for (let x = range[0]; x <= range[1]; x += stepSize) {
            xValues.push(x);
            gValues.push(state.g(x));
        }
        
        Plotly.newPlot(plotContainer, [
            { x: xValues, y: gValues, mode: 'lines', name: 'y = g(x)', line: { color: 'royalblue' } },
            { x: range, y: range, mode: 'lines', name: 'y = x', line: { color: 'grey', dash: 'dash' } }
        ], {
            title: `Plot of y = g(x) and y = x`,
            xaxis: { title: 'x', gridcolor: '#e0e0e0', range: range },
            yaxis: { title: 'y', gridcolor: '#e0e0e0', scaleanchor: 'x', scaleratio: 1 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: '#ffffff',
            margin: { l: 50, r: 25, t: 40, b: 40 },
            showlegend: false
        }, {responsive: true, displaylogo: false});
    }
    
    function updatePlotAnnotations() {
        const traces = [];
        for (let i = 0; i < state.log.length - 1; i++) {
            const x_prev = state.log[i].x;
            const x_next = state.log[i+1].x;
            // Vertical line: (x_prev, x_prev) -> (x_prev, x_next)
            traces.push({ x: [x_prev, x_prev], y: [x_prev, x_next], mode: 'lines', line: { color: 'rgba(211, 47, 47, 0.6)', width: 1.5 } });
            // Horizontal line: (x_prev, x_next) -> (x_next, x_next)
            traces.push({ x: [x_prev, x_next], y: [x_next, x_next], mode: 'lines', line: { color: 'rgba(76, 175, 80, 0.8)', width: 1.5 } });
        }
        Plotly.addTraces(plotContainer, traces);
    }
    
    initialize();
});
</script>
</body>
</html>
