<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Interactive Polynomial Explorer â€“ Smart Analysis</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        /* Reusing styles from the first app */
        :root{
            --blue:#1565c0;
            --blue-dark:#0d47a1;
            --green:#43a047;
            --orange:#e65100;
            --grey:#bdbdbd;
            --red:#d32f2f;
            --surface:#fff;
            --surface-alt:#f4f4fa;
            --font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;
        }
        html,body{
            margin:0;
            padding:0;
            height:100%;
            font-family:var(--font-family);
            background:var(--surface-alt);
            color:#222;
        }
        .container{
            max-width:1120px;
            margin:20px auto;
            background:var(--surface);
            border-radius:14px;
            box-shadow:0 4px 16px #0000000d;
            padding:1.5rem 2rem;
        }
        h2{
            margin-top:0;
            color: var(--blue-dark);
        }
        .main-layout{
            display:flex;
            flex-wrap:wrap;
            gap:2.4rem;
            align-items:flex-start;
        }
        .panel{
            flex:1 1 500px;
            min-width:320px;
        }
        button{
            cursor:pointer;
            border:none;
            border-radius:6px;
            font-size:1em;
            padding:0.5em 1em;
            transition:filter .15s,transform .15s;
            background:var(--blue);
            color:#fff;
        }
        button:hover{filter:brightness(1.1)}
        button:active{transform:scale(0.97)}
        button:disabled{background:#ccc!important;cursor:not-allowed;filter:none}
        select,input[type="range"] {
            font-size:inherit;
            padding:0.3em 0.35em;
            border:1px solid #ccc;
            border-radius:4px;
            box-sizing:border-box;
            -webkit-appearance: none; /* Remove default styling for range input */
            appearance: none;
            background: #f0f0f0; /* Track color */
            outline: none;
            height: 8px; /* Height of the track */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Thumb width */
            height: 18px; /* Thumb height */
            border-radius: 50%; /* Make it circular */
            background: var(--blue); /* Thumb color */
            cursor: pointer;
            margin-top: -5px; /* Adjust thumb vertical position */
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--blue);
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        select { width: 100%; }

        .controls { margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .sliders { margin-top: 10px; }
        .slider-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group label { min-width: 150px; }
        .slider-group input[type="range"] { flex-grow: 1; }
        .slider-group span { min-width: 30px; text-align: right; font-weight: bold; }

        .info-panel {
            margin-top: 20px;
            background: var(--surface-alt);
            padding: 1.2em;
            border-radius: 8px;
            border: 1px solid #e8eef8;
            font-size: 0.9rem;
            line-height: 1.6;
            /* New positioning */
            width: 100%; /* Take full width */
            box-sizing: border-box; /* Include padding/border in width */
        }
        .info-panel h3 {
            margin-top: 0;
            color: var(--blue-dark);
        }
        .info-panel strong {
            font-weight: 600;
            color: #333;
        }
        @media(max-width:900px){
            .main-layout{flex-direction:column}
            .panel{flex-basis:auto;width:100%}
        }
        /* Further adjustments for smaller screens if needed */
        @media(max-width:600px) {
            .container { padding: 1rem; margin: 10px auto; }
            .main-layout { gap: 1.5rem; }
            .controls { flex-direction: column; align-items: flex-start; }
            .slider-group { flex-wrap: wrap; }
            .slider-group label { min-width: unset; width: 100%; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>ðŸ§® Interactive Polynomial Explorer</h2>

        <div class="controls">
            <label for="degree">Select polynomial degree (1â€“5): </label>
            <select id="degree">
                <option value="1">1 (Linear)</option>
                <option value="2">2 (Quadratic)</option>
                <option value="3">3 (Cubic)</option>
                <option value="4" selected>4 (Quartic)</option> <option value="5">5 (Quintic)</option>
            </select>
        </div>

        <div class="main-layout">
            <div class="panel">
                <div id="sliders" class="sliders"></div>
            </div>
            <div class="panel">
                <div id="plot" style="width: 100%; height: 400px;"></div>
            </div>
        </div>

        <div class="info-panel">
            <h3>ðŸ“Š Polynomial Properties</h3>
            <div id="properties">Add coefficients to begin analysis.</div>
        </div>
    </div>

    <script>
        const slidersDiv = document.getElementById("sliders");
        const degreeSelector = document.getElementById("degree");
        const plotDiv = document.getElementById("plot");
        const propsDiv = document.getElementById("properties");

        let sliders = [];

        const varStr = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
        const epsilon = 1e-6; // Threshold for considering values close to zero

        // Reusable function for formatting intervals
        function formatIntervals(arr) {
            if (arr.length === 0) return 'None';
            arr.sort((a, b) => {
                const startA = a.start === -Infinity ? -Infinity : a.start;
                const startB = b.start === -Infinity ? -Infinity : b.start;
                return startA - startB;
            });

            const mergedIntervals = [];
            if (arr.length > 0) {
                let current = { ...arr[0] };
                for (let i = 1; i < arr.length; i++) {
                    const next = arr[i];
                    const currentEnd = current.end === Infinity ? Infinity : current.end;
                    const nextStart = next.start === -Infinity ? -Infinity : next.start;

                    // Check for overlap or contiguity
                    // If the next interval starts before or very close to the current one's end
                    if (nextStart <= currentEnd + epsilon) {
                        // Merge by extending the current interval's end
                        current.end = Math.max(currentEnd, next.end === Infinity ? Infinity : next.end);
                        // If the next interval's start type is 'open' and it's the same start point,
                        // prefer 'open' for the combined interval
                        if (nextStart === current.start && next.startType === 'open') {
                             current.startType = 'open';
                        }
                    } else {
                        // No overlap, push current and start new one
                        mergedIntervals.push(current);
                        current = { ...next };
                    }
                }
                mergedIntervals.push(current);
            }

            return mergedIntervals.map(i => {
                const openChar = i.startType === 'open' ? '(' : '[';
                const closeChar = i.endType === 'open' ? ')' : ']';
                const startVal = (i.start === -Infinity || i.start === '-Infinity') ? 'âˆ’âˆž' : parseFloat(i.start).toFixed(2);
                const endVal = (i.end === Infinity || i.end === '+Infinity') ? '+âˆž' : parseFloat(i.end).toFixed(2);
                return `${openChar}${startVal}, ${endVal}${closeChar}`;
            }).join(' \u222A '); // Union symbol
        }

        function createSliders(degree) {
            slidersDiv.innerHTML = "";
            sliders = [];

            for (let i = degree; i >= 0; i--) {
                const group = document.createElement("div");
                group.className = "slider-group";

                const label = document.createElement("label");
                label.innerText = `Coefficient of x^${i}: `;

                const input = document.createElement("input");
                input.type = "range";
                input.min = -10;
                input.max = 10;
                input.step = 0.1;
                // Set initial leading coefficient to 1, others to 0
                input.value = (i === degree && degree !== 0) ? 1 : 0;
                if (degree === 0) input.value = 1; // For constant function, default to 1

                input.dataset.power = i;

                const span = document.createElement("span");
                span.innerText = input.value;

                input.oninput = () => {
                    span.innerText = input.value;
                    updateGraph();
                };

                group.appendChild(label);
                group.appendChild(input);
                group.appendChild(span);
                slidersDiv.appendChild(group);

                sliders.push(input);
            }
            updateGraph();
        }

        function getPolynomialExpr() {
            let terms = sliders.map(s => {
                let coef = parseFloat(s.value);
                let pow = parseInt(s.dataset.power);

                if (Math.abs(coef) < epsilon) return null; // Skip near-zero coefficients

                let termStr;
                if (pow === 0) {
                    termStr = `${coef}`;
                } else if (pow === 1) {
                    if (coef === 1) termStr = `x`;
                    else if (coef === -1) termStr = `-x`;
                    else termStr = `${coef}*x`;
                } else {
                    if (coef === 1) termStr = `x^${pow}`;
                    else if (coef === -1) termStr = `-x^${pow}`;
                    else termStr = `${coef}*x^${pow}`;
                }
                return termStr;
            }).filter(Boolean); // Remove nulls (zero coefficient terms)

            // Join terms, replacing "+ -" with "-" for cleaner display
            return terms.length ? terms.join(" + ").replace(/\+ -/g, "- ") : "0";
        }


        function updateGraph() {
            const currentDegree = parseInt(degreeSelector.value);
            const expr = getPolynomialExpr();
            const node = math.parse(expr);
            const f = node.compile();

            // Handle constant function (degree 0) explicitly
            if (currentDegree === 0 || expr === "0") { // Check for "0" as well for all zero coefficients
                 const x_vals_plot = math.range(-10, 10, 0.1).toArray();
                 const y_val = (expr === "0") ? 0 : parseFloat(sliders[0].value); // Get coefficient for c_0 or 0
                 const y_vals_plot = x_vals_plot.map(() => y_val);

                 Plotly.newPlot(plotDiv, [{
                    x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                    line: { color: varStr('--blue') }
                 }], {
                    margin: { t: 50 }, // Increased top margin for title visibility
                    title: {
                        text: `f(x) = ${expr.replace(/\*/g, '')}`,
                        y: 0.95, // Adjust title vertical position
                        x: 0.5,
                        xanchor: 'center',
                        yanchor: 'top',
                        font: { size: 18 } // Make title slightly larger for visibility
                    },
                    font: { family: varStr('--font-family'), color: '#222' },
                    xaxis: { title: 'x', range: [-10, 10] },
                    yaxis: { title: 'f(x)' }
                 });

                 propsDiv.innerHTML = `
                    <strong>Function:</strong> f(x) = ${expr.replace(/\*/g, '')}<br/><br/>
                    <strong>Increasing Intervals:</strong> None<br/>
                    <strong>Decreasing Intervals:</strong> None<br/>
                    <strong>Constant Intervals:</strong> [âˆ’âˆž, +âˆž]<br/>
                    <br/>
                    <strong>Concave Up:</strong> None<br/>
                    <strong>Concave Down:</strong> None<br/>
                    <strong>Inflection Points:</strong> None
                 `;
                 return;
            }

            // For non-constant functions, calculate derivatives
            const df_node = math.derivative(node, 'x');
            const df = df_node.compile();
            const ddf_node = math.derivative(df_node, 'x');
            const ddf = ddf_node.compile();

            // Extended range for more robust critical/inflection point detection
            const x_analysis_min = -20;
            const x_analysis_max = 20;
            const x_vals_full = math.range(x_analysis_min, x_analysis_max, 0.005).toArray(); // Finer step for precision
            const dy_vals_full = x_vals_full.map(x => df.evaluate({ x }));
            const ddy_vals_full = x_vals_full.map(x => ddf.evaluate({ x }));

            // Filter x_vals for plotting to the visible range [-10, 10]
            const x_vals_plot = math.range(-10, 10, 0.1).toArray();
            const y_vals_plot = x_vals_plot.map(x => f.evaluate({x}));


            Plotly.newPlot(plotDiv, [{
                x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                line: { color: varStr('--blue') }
            }], {
                margin: { t: 50 }, // Increased top margin for title visibility
                title: {
                    text: `f(x) = ${expr.replace(/\*/g, '')}`,
                    y: 0.95, // Adjust title vertical position
                    x: 0.5,
                    xanchor: 'center',
                    yanchor: 'top',
                    font: { size: 18 } // Make title slightly larger for visibility
                },
                font: { family: varStr('--font-family'), color: '#222' },
                xaxis: { title: 'x', range: [-10, 10] },
                yaxis: { title: 'f(x)' }
            });

            // Helper to find roots by detecting sign changes
            const findRoots = (values, xCoords) => {
                const roots = new Set();
                for (let i = 0; i < values.length - 1; i++) {
                    const y1 = values[i];
                    const y2 = values[i+1];
                    const x1 = xCoords[i];
                    const x2 = xCoords[i+1];

                    // Check for sign change or if segment is very close to zero
                    if ((y1 < -epsilon && y2 > epsilon) ||
                        (y1 > epsilon && y2 < -epsilon) ||
                        (Math.abs(y1) < epsilon && Math.abs(y2) < epsilon)
                       ) {
                        if (Math.abs(y2 - y1) > epsilon) { // If not flat, interpolate
                            const rootX = x1 - y1 * (x2 - x1) / (y2 - y1);
                            roots.add(rootX);
                        } else { // If flat (near zero for both points), consider midpoint
                            roots.add((x1 + x2) / 2);
                        }
                    }
                }
                return Array.from(roots).sort((a,b) => a-b);
            };

            const criticalPoints = findRoots(dy_vals_full, x_vals_full);
            const inflectionCandidates = findRoots(ddy_vals_full, x_vals_full);

            // Determine end behavior based on leading coefficients
            const leadingCoefNode = sliders.find(s => parseInt(s.dataset.power) === currentDegree);
            let leadingCoef_f = leadingCoefNode ? parseFloat(leadingCoefNode.value) : 0;

            // f'(x) end behavior
            let fPrimeEndBehaviorSignAtPosInf = 0;
            let fPrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 0) {
                const f_prime_leading_coef_val = currentDegree * leadingCoef_f;
                if (Math.abs(f_prime_leading_coef_val) > epsilon) {
                    fPrimeEndBehaviorSignAtPosInf = Math.sign(f_prime_leading_coef_val);
                    if ((currentDegree - 1) % 2 !== 0) { // If degree-1 is odd
                        fPrimeEndBehaviorSignAtNegInf = -fPrimeEndBehaviorSignAtPosInf;
                    } else { // If degree-1 is even
                        fPrimeEndBehaviorSignAtNegInf = fPrimeEndBehaviorSignAtPosInf;
                    }
                }
            }

            // f''(x) end behavior
            let fDoublePrimeEndBehaviorSignAtPosInf = 0;
            let fDoublePrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 1) {
                const f_double_prime_leading_coef_val = currentDegree * (currentDegree - 1) * leadingCoef_f;
                if (Math.abs(f_double_prime_leading_coef_val) > epsilon) {
                    fDoublePrimeEndBehaviorSignAtPosInf = Math.sign(f_double_prime_leading_coef_val);
                    if ((currentDegree - 2) % 2 !== 0) { // If degree-2 is odd
                        fDoublePrimeEndBehaviorSignAtNegInf = -fDoublePrimeEndBehaviorSignAtPosInf;
                    } else { // If degree-2 is even
                        fDoublePrimeEndBehaviorSignAtNegInf = fDoublePrimeEndBehaviorSignAtPosInf;
                    }
                }
            }


            // Combine all unique critical and inflection points from analysis range
            const allAnalysisPoints = Array.from(new Set([...criticalPoints, ...inflectionCandidates]))
                .sort((a,b) => a-b);

            const increasing = [];
            const decreasing = [];
            const constant = [];
            const concaveUp = [];
            const concaveDown = [];
            const finalInflectionPoints = new Set();


            // Helper to get behavior sign at a test point
            const getBehaviorSign = (x, derivativeType) => {
                if (x < x_analysis_min) { // Before analysis range
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtNegInf : fDoublePrimeEndBehaviorSignAtNegInf;
                } else if (x > x_analysis_max) { // After analysis range
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtPosInf : fDoublePrimeEndBehaviorSignAtPosInf;
                } else { // Within analysis range, evaluate numerically
                    try {
                        if (derivativeType === 'first') return Math.sign(df.evaluate({ x }));
                        if (derivativeType === 'second') return Math.sign(ddf.evaluate({ x }));
                    } catch (e) {
                        return 0; // In case of math error
                    }
                }
            };

            // Analyze intervals
            let prevPoint = -Infinity;
            const pointsToProcess = [...allAnalysisPoints, Infinity]; // Include infinity as the last boundary

            for (const currentPoint of pointsToProcess) {
                if (currentPoint <= prevPoint + epsilon && currentPoint !== Infinity) { // Skip duplicate or too-close points
                    continue;
                }

                const intervalStart = prevPoint;
                const intervalEnd = currentPoint;
                let testX;

                // Pick a test point within the interval, or near the boundary for infinite intervals
                if (intervalStart === -Infinity) {
                    testX = currentPoint === Infinity ? 0 : currentPoint - 1; // if (.-inf,inf), test 0, else (.-inf,X) test X-1
                    if (testX < x_analysis_min) testX = x_analysis_min - 1; // Ensure test point is outside if needed
                } else if (intervalEnd === Infinity) {
                    testX = intervalStart + 1;
                    if (testX > x_analysis_max) testX = x_analysis_max + 1; // Ensure test point is outside if needed
                } else {
                    testX = (intervalStart + intervalEnd) / 2;
                }

                const dy_sign = getBehaviorSign(testX, 'first');
                const ddy_sign = getBehaviorSign(testX, 'second');

                const intervalObj = {
                    start: intervalStart,
                    end: intervalEnd,
                    startType: 'open',
                    endType: 'open'
                };

                if (dy_sign > 0) {
                    increasing.push(intervalObj);
                } else if (dy_sign < 0) {
                    decreasing.push(intervalObj);
                } else {
                    constant.push(intervalObj);
                }

                if (ddy_sign > 0) {
                    concaveUp.push(intervalObj);
                } else if (ddy_sign < 0) {
                    concaveDown.push(intervalObj);
                }

                prevPoint = currentPoint;
            }

            // Add precise inflection points - only those where ddy truly crosses zero
            inflectionCandidates.forEach(p => {
                const y_dd_at_p = ddf.evaluate({x:p});
                if (Math.abs(y_dd_at_p) < epsilon) { // Confirm it's actually a root
                    // Check for a sign change around p
                    const sign_left = getBehaviorSign(p - epsilon * 10, 'second');
                    const sign_right = getBehaviorSign(p + epsilon * 10, 'second');
                    if (sign_left !== sign_right && sign_left !== 0 && sign_right !== 0) {
                        finalInflectionPoints.add(p.toFixed(2));
                    }
                }
            });


            propsDiv.innerHTML = `
                <strong>Function:</strong> f(x) = ${expr.replace(/\*/g, '')}<br/><br/>
                <strong>Increasing Intervals:</strong> ${formatIntervals(increasing)}<br/>
                <strong>Decreasing Intervals:</strong> ${formatIntervals(decreasing)}<br/>
                <strong>Constant Intervals:</strong> ${formatIntervals(constant)}<br/>
                <br/>
                <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br/>
                <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}<br/>
                <strong>Inflection Points:</strong> ${Array.from(finalInflectionPoints).sort((a,b) => parseFloat(a)-parseFloat(b)).join(', ') || 'None'}
            `;
        }

        // Initialize
        degreeSelector.addEventListener("change", () => {
            createSliders(parseInt(degreeSelector.value));
        });

        degreeSelector.value = "4"; // Set default degree to 4 as in the screenshot
        createSliders(parseInt(degreeSelector.value));
    </script>
</body>
</html>
