<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Interactive Polynomial Explorer â€“ Smart Analysis</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        :root {
            --blue: #1976d2;
            --blue-dark: #0d47a1;
            --blue-light: #e3f2fd;
            --green: #43a047;
            --orange: #ff9800;
            --grey: #bdbdbd;
            --surface: #fff;
            --surface-alt: #f7f8fa;
            --surface-accent: #ecf3fc;
            --shadow: 0 4px 32px #0d47a125;
            --shadow-sm: 0 2px 8px #0d47a120;
            --radius: 18px;
            --radius-sm: 8px;
            --font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: var(--font-family);
            background: linear-gradient(125deg, var(--surface-alt) 70%, var(--blue-light) 100%);
            color: #1a202c;
        }
        .container {
            max-width: 1080px;
            margin: 2rem auto;
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 2.2rem 2.2rem 1.7rem 2.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.6rem;
            border: 1.5px solid #e3e6f5;
        }
        h2 {
            margin-top: 0;
            color: var(--blue-dark);
            font-size: 2.25rem;
            letter-spacing: 0.01em;
            font-weight: 800;
            background: linear-gradient(90deg, var(--blue-dark) 50%, var(--blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 0.8rem;
            user-select: none;
        }
        .main-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 2.2rem;
            align-items: stretch;
            width: 100%;
            justify-content: center;
        }
        .panel {
            flex: 1 1 470px;
            min-width: 320px;
            background: var(--surface-accent);
            border-radius: var(--radius);
            padding: 1.3rem 1.3rem 1.1rem 1.3rem;
            box-shadow: var(--shadow-sm);
            transition: box-shadow .22s;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            border: 1.5px solid #dde7fa;
        }
        .panel:hover {
            box-shadow: 0 8px 36px #1565c025;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 10px;
            padding: 0.5rem 1.2rem 0.5rem 1.2rem;
            background: linear-gradient(90deg, var(--blue-light) 0%, #f9fafb 80%);
            border-radius: var(--radius-sm);
            box-shadow: 0 1px 4px #90caf930;
            border: 1px solid #e0e7ef;
        }
        .controls label {
            font-weight: 500;
            letter-spacing: 0.01em;
            margin-right: 0.4em;
        }
        .sliders {
            margin-top: 10px;
            width: 100%;
        }
        .slider-group {
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            gap: 1.2em;
        }
        .slider-group label {
            min-width: 135px;
            font-weight: 500;
            color: var(--blue-dark);
            font-size: 1.01em;
            letter-spacing: 0.01em;
        }
        .slider-group span {
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            color: var(--blue);
            font-size: 1.12em;
            padding-left: 0.2em;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: linear-gradient(90deg, var(--blue-light) 60%, #f0f4fc 100%);
            height: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 8px #90caf920;
            outline: none;
            transition: box-shadow 0.18s;
        }
        input[type="range"]:focus {
            box-shadow: 0 2px 12px #1976d250;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--blue) 60%, var(--blue-dark) 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px #1565c045;
            border: 2.5px solid #fff;
            transition: background 0.18s, transform 0.12s;
        }
        input[type="range"]:focus::-webkit-slider-thumb,
        input[type="range"]::-webkit-slider-thumb:hover {
            background: linear-gradient(120deg, var(--blue-dark) 60%, var(--blue) 100%);
            transform: scale(1.04);
        }
        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--blue) 60%, var(--blue-dark) 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px #1565c045;
            border: 2.5px solid #fff;
            transition: background 0.18s, transform 0.12s;
        }
        input[type="range"]:focus::-moz-range-thumb,
        input[type="range"]::-moz-range-thumb:hover {
            background: linear-gradient(120deg, var(--blue-dark) 60%, var(--blue) 100%);
            transform: scale(1.04);
        }
        input[type="range"]:focus {
            outline: none;
        }
        select {
            width: 110px;
            padding: 0.4em 1.7em 0.4em 0.7em;
            border: 1.5px solid #c2dafc;
            border-radius: 7px;
            background: var(--surface);
            font-size: 1em;
            font-family: inherit;
            box-shadow: 0 1px 4px #1976d220;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%231976d2" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.5em center;
            background-size: 1.3em;
            transition: border-color 0.14s;
            font-weight: 500;
        }
        select:focus, select:hover {
            border-color: var(--blue-dark);
            outline: none;
        }
        button {
            cursor: pointer;
            border: none;
            border-radius: 7px;
            font-size: 1em;
            padding: 0.57em 1.3em;
            background: linear-gradient(90deg, var(--blue-dark) 40%, var(--blue) 100%);
            color: #fff;
            font-weight: 600;
            box-shadow: 0 2px 8px #1976d225;
            transition: filter .12s,transform .12s, box-shadow .18s;
        }
        button:hover { filter: brightness(1.1); box-shadow: 0 4px 18px #1976d235;}
        button:active { transform: scale(0.96); }
        button:disabled { background: #ccc !important; cursor: not-allowed; filter: none; }
        #plot {
            width: 100%;
            min-height: 350px;
            background: #fff;
            border-radius: var(--radius-sm);
            border: 1.5px solid #d1e2fb;
            box-shadow: 0 2px 10px #90caf930;
            margin-bottom: 0.2em;
            padding: 0.2em;
        }
        .info-panel {
            margin-top: 22px;
            background: linear-gradient(100deg, #eaf3fd 65%, #f8fafc 100%);
            padding: 1.4em 2em 1.3em 2em;
            border-radius: var(--radius);
            border: 1.5px solid #c9daf8;
            font-size: 1.01rem;
            line-height: 1.68;
            width: 100%;
            box-sizing: border-box;
            box-shadow: var(--shadow-sm);
            text-align: left;
            letter-spacing: 0.01em;
            color: #202336;
        }
        .info-panel h3 {
            margin-top: 0;
            color: var(--blue-dark);
            text-align: center;
            font-size: 1.27em;
            margin-bottom: 0.5em;
            font-weight: 700;
            letter-spacing: 0.02em;
            background: linear-gradient(90deg, var(--blue-dark) 40%, var(--blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .info-panel strong {
            font-weight: 700;
            color: var(--blue-dark);
        }
        .rescale-badge {
            position: absolute;
            top: 28px;
            right: 38px;
            background: #1976d2;
            color: #fff;
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1em;
            box-shadow: 0 2px 8px #1976d265;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s;
            z-index: 20;
            letter-spacing: 0.03em;
            user-select: none;
        }
        @media (max-width: 950px) {
            .main-layout { flex-direction: column; gap: 1.4rem; }
            .panel { flex-basis: auto; min-width: unset; width: 100%; }
        }
        @media (max-width: 600px) {
            .container { padding: 1.2rem 0.3rem 0.6rem 0.3rem; margin: 7px auto; }
            h2 { font-size: 1.45rem; }
            .main-layout { gap: 1.05rem; }
            .controls { flex-direction: column; align-items: stretch; padding: 0.7rem; }
            .panel { padding: 0.85rem 0.6rem; }
            .info-panel { padding: 0.8em 0.5em 1em 0.5em; font-size: 0.99rem;}
            .slider-group label { min-width: unset; width: 100%; font-size: 1em; }
            select { width: 100%; min-width: unset;}
            .rescale-badge { top: 10px; right: 10px; font-size: 0.9em; padding: 5px 10px;}
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Interactive Polynomial Explorer</h2>
        <div class="controls">
            <label for="degree">Select polynomial degree (1â€“4): </label>
            <select id="degree">
                <option value="1">1 (Linear)</option>
                <option value="2">2 (Quadratic)</option>
                <option value="3">3 (Cubic)</option>
                <option value="4" selected>4 (Quartic)</option>
            </select>
        </div>
        <div class="main-layout">
            <div class="panel">
                <div id="sliders" class="sliders"></div>
            </div>
            <div class="panel" id="plot-panel" style="position:relative;">
                <div id="plot"></div>
                <div id="rescale-badge" class="rescale-badge">Y-axis rescaled</div>
            </div>
        </div>
        <div class="info-panel">
            <h3>ðŸ“Š Polynomial Properties</h3>
            <div id="properties">Add coefficients to begin analysis.</div>
        </div>
    </div>
    <script>
        const slidersDiv = document.getElementById("sliders");
        const degreeSelector = document.getElementById("degree");
        const plotDiv = document.getElementById("plot");
        const propsDiv = document.getElementById("properties");
        const rescaleBadge = document.getElementById("rescale-badge");

        let sliders = [];

        const varStr = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
        const epsilon = 1e-6;

        function showRescaleBadge() {
            rescaleBadge.style.opacity = '1';
            clearTimeout(showRescaleBadge._timeout);
            showRescaleBadge._timeout = setTimeout(() => {
                rescaleBadge.style.opacity = '0';
            }, 900);
        }

        function formatPower(base, exponent) {
            if (exponent === 0) return base;
            if (exponent === 1) return base;
            return `${base}<sup>${exponent}</sup>`;
        }

        function formatExpressionForDisplay(expr) {
            return expr.replace(/x\^(\d+)/g, (match, p1) => {
                const exponent = parseInt(p1);
                if (exponent === 0) return '';
                if (exponent === 1) return 'x';
                return `x<sup>${exponent}</sup>`;
            });
        }

        function formatIntervals(arr) {
            if (arr.length === 0) return 'None';
            arr.sort((a, b) => {
                const startA = a.start === -Infinity ? -Infinity : a.start;
                const startB = b.start === -Infinity ? -Infinity : b.start;
                return startA - startB;
            });
            const mergedIntervals = [];
            if (arr.length > 0) {
                let current = { ...arr[0] };
                for (let i = 1; i < arr.length; i++) {
                    const next = arr[i];
                    const currentEnd = current.end === Infinity ? Infinity : current.end;
                    const nextStart = next.start === -Infinity ? -Infinity : next.start;
                    if (nextStart <= currentEnd + epsilon) {
                        current.end = Math.max(currentEnd, next.end === Infinity ? Infinity : next.end);
                        current.endType = next.endType;
                        if (nextStart === current.start && next.startType === 'open') {
                            current.startType = 'open';
                        }
                    } else {
                        mergedIntervals.push(current);
                        current = { ...next };
                    }
                }
                mergedIntervals.push(current);
            }
            return mergedIntervals.map(i => {
                const openChar = i.startType === 'open' ? '(' : '[';
                const closeChar = i.endType === 'open' ? ')' : ']';
                let startVal = (i.start === -Infinity || i.start === '-Infinity') ? 'âˆ’âˆž' : parseFloat(i.start).toFixed(2);
                let endVal = (i.end === Infinity || i.end === '+Infinity') ? '+âˆž' : parseFloat(i.end).toFixed(2);
                if (parseFloat(startVal) === 0) startVal = '0';
                if (parseFloat(endVal) === 0) endVal = '0';
                return `${openChar}${startVal}, ${endVal}${closeChar}`;
            }).join(' \u222A ');
        }

        function createSliders(degree) {
            slidersDiv.innerHTML = "";
            sliders = [];
            for (let i = degree; i >= 0; i--) {
                const group = document.createElement("div");
                group.className = "slider-group";
                const label = document.createElement("label");
                label.innerHTML = i === 0 ? 'Constant term:' : `Coefficient of ${formatPower('x', i)}: `;
                const input = document.createElement("input");
                input.type = "range";
                input.min = -10;
                input.max = 10;
                input.step = 0.1;
                input.value = (i === degree && degree !== 0) ? 1 : 0;
                if (degree === 0) input.value = 1;
                input.dataset.power = i;
                const span = document.createElement("span");
                span.innerText = input.value;
                input.oninput = () => {
                    span.innerText = input.value;
                    updateGraph();
                };
                group.appendChild(label);
                group.appendChild(input);
                group.appendChild(span);
                slidersDiv.appendChild(group);
                sliders.push(input);
            }
            updateGraph();
        }

        // Helpers for root-based interval splitting
        function getCoefficients() {
            return sliders.map(s => parseFloat(s.value)).reverse();
        }
        function getDerivativeCoefficients(coeffs, order = 1) {
            let current = coeffs.slice();
            for (let k = 0; k < order; k++) {
                const next = [];
                for (let i = 0; i < current.length - 1; i++) {
                    next.push(current[i] * (current.length - i - 1));
                }
                current = next;
            }
            return current;
        }
        function getRealRoots(coeffs) {
            try {
                let roots = math.roots(coeffs);
                return roots
                    .filter(r => Math.abs(r.im || 0) < 1e-6)
                    .map(r => typeof r === "number" ? r : r.re)
                    .filter(x => x > -21 && x < 21); // inside analysis window
            } catch (e) { return []; }
        }

        // New: Robust interval splitting, always covers the line
        function splitIntervalsByPoints(roots, testFunc, leadingCoef, degree) {
            const intervals = [];
            const points = [-Infinity, ...roots, Infinity];
            for (let i = 0; i < points.length - 1; i++) {
                let a = points[i], b = points[i + 1];
                let mid;
                if (!isFinite(a) && isFinite(b)) mid = b - 1;
                else if (isFinite(a) && !isFinite(b)) mid = a + 1;
                else if (!isFinite(a) && !isFinite(b)) mid = 0;
                else mid = (a + b) / 2;
                let sign;
                try {
                    sign = Math.sign(testFunc(mid));
                    if (sign === 0) sign = Math.sign(testFunc(mid + 1e-4)) || Math.sign(testFunc(mid - 1e-4));
                } catch (e) {
                    if (!isFinite(mid)) {
                        if (degree % 2 === 0) sign = Math.sign(leadingCoef);
                        else sign = (mid === -Infinity ? -1 : 1) * Math.sign(leadingCoef);
                    } else {
                        sign = 0;
                    }
                }
                intervals.push({ start: a, end: b, startType: 'open', endType: 'open', sign });
            }
            return intervals;
        }

        function getPolynomialExpr() {
            let terms = sliders.map(s => {
                let coef = parseFloat(s.value);
                let pow = parseInt(s.dataset.power);
                if (Math.abs(coef) < epsilon) return null;
                let termStr;
                if (pow === 0) {
                    termStr = `${coef}`;
                } else if (pow === 1) {
                    if (coef === 1) termStr = `x`;
                    else if (coef === -1) termStr = `-x`;
                    else termStr = `${coef}*x`;
                } else {
                    if (coef === 1) termStr = `x^${pow}`;
                    else if (coef === -1) termStr = `-x^${pow}`;
                    else termStr = `${coef}*x^${pow}`;
                }
                return termStr;
            }).filter(Boolean);
            return terms.length ? terms.join(" + ").replace(/\+ -/g, "- ") : "0";
        }

        function updateGraph() {
            const currentDegree = parseInt(degreeSelector.value);
            const rawExpr = getPolynomialExpr();
            const displayExpr = formatExpressionForDisplay(rawExpr.replace(/\*/g, ''));
            const node = math.parse(rawExpr);
            const f = node.compile();

            if (currentDegree === 0 || rawExpr === "0") {
                const x_vals_plot = math.range(-10, 10, 0.1).toArray();
                const y_val = (rawExpr === "0") ? 0 : parseFloat(sliders[0].value);
                const y_vals_plot = x_vals_plot.map(() => y_val);
                Plotly.react(plotDiv, [{
                    x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                    line: { color: varStr('--blue') }
                }], {
                    margin: { t: 50 },
                    title: {
                        text: `f(x) = ${displayExpr}`,
                        y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                        font: { size: 18, family: varStr('--font-family') }
                    },
                    font: { family: varStr('--font-family'), color: '#222' },
                    xaxis: { title: 'x', range: [-10, 10] },
                    yaxis: { title: 'f(x)', range: [-10, 10] }
                }, {responsive:true, animate: true});
                propsDiv.innerHTML = `
                    <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                    <strong>Increasing Intervals:</strong> None<br/>
                    <strong>Decreasing Intervals:</strong> None<br/>
                    <strong>Constant Intervals:</strong> [âˆ’âˆž, +âˆž]<br/>
                    <br/>
                    <strong>Concave Up:</strong> None<br/>
                    <strong>Concave Down:</strong> None<br/>
                    <strong>Inflection Points:</strong> None
                 `;
                return;
            }
            // math.js-based root finding for critical points and inflection points
            const coeffs = getCoefficients();
            const dCoeffs = getDerivativeCoefficients(coeffs, 1);
            const ddCoeffs = getDerivativeCoefficients(coeffs, 2);
            const criticalPoints = getRealRoots(dCoeffs);
            const inflectionCandidates = getRealRoots(ddCoeffs);

            // For plotting and for behaviour checks
            const x_analysis_min = -20;
            const x_analysis_max = 20;
            const x_vals_plot = math.range(-10, 10, 0.1).toArray();
            const y_vals_plot = x_vals_plot.map(x => f.evaluate({x}));

            // y-scaling
            const minY = Math.min(...y_vals_plot);
            const maxY = Math.max(...y_vals_plot);
            let yMin = Math.max(minY, -1000);
            let yMax = Math.min(maxY, 1000);
            if (Math.abs(yMax - yMin) < 1e-3) {
                yMin -= 1;
                yMax += 1;
            }
            if (typeof updateGraph.prevYMin !== 'undefined') {
                if (Math.abs(updateGraph.prevYMin - yMin) > 0.2 || Math.abs(updateGraph.prevYMax - yMax) > 0.2) {
                    showRescaleBadge();
                }
            }
            updateGraph.prevYMin = yMin;
            updateGraph.prevYMax = yMax;

            Plotly.react(plotDiv, [{
                x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                line: { color: varStr('--blue') }
            }], {
                margin: { t: 50 },
                title: {
                    text: `f(x) = ${displayExpr}`,
                    y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                    font: { size: 18, family: varStr('--font-family') }
                },
                font: { family: varStr('--font-family'), color: '#222' },
                xaxis: { title: 'x', range: [-10, 10] },
                yaxis: { title: 'f(x)', range: [yMin, yMax] }
            }, {responsive:true, animate: true});

            // Robust interval detection for monotonicity and concavity
            const df_node = math.derivative(node, 'x');
            const df = df_node.compile();
            const ddf_node = math.derivative(df_node, 'x');
            const ddf = ddf_node.compile();
            const leadingCoef = coeffs[0];
            const dLeadingCoef = dCoeffs[0] || 0;
            const ddLeadingCoef = ddCoeffs[0] || 0;

            // Increasing/decreasing intervals
            const critPoints = Array.from(new Set(criticalPoints)).sort((a, b) => a - b);
            const monotonicIntervals = splitIntervalsByPoints(critPoints, x => df.evaluate({ x }), dLeadingCoef, currentDegree - 1);

            // Concavity intervals
            const inflectPoints = Array.from(new Set(inflectionCandidates)).sort((a, b) => a - b);
            const concavityIntervals = splitIntervalsByPoints(inflectPoints, x => ddf.evaluate({ x }), ddLeadingCoef, currentDegree - 2);

            const increasing = monotonicIntervals.filter(i => i.sign > 0);
            const decreasing = monotonicIntervals.filter(i => i.sign < 0);
            const constant = monotonicIntervals.filter(i => i.sign === 0);

            const concaveUp = concavityIntervals.filter(i => i.sign > 0);
            const concaveDown = concavityIntervals.filter(i => i.sign < 0);

            // Inflection points: check sign change in f'' at each candidate
            const finalInflectionPoints = new Set();
            for (let p of inflectionCandidates) {
                const left = p - 1e-5;
                const right = p + 1e-5;
                const sign_left = Math.sign(ddf.evaluate({x:left}));
                const sign_right = Math.sign(ddf.evaluate({x:right}));
                if (sign_left !== sign_right && sign_left !== 0 && sign_right !== 0) {
                    finalInflectionPoints.add(Number(p).toFixed(4));
                }
            }

            propsDiv.innerHTML = `
                <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                <strong>Increasing Intervals:</strong> ${formatIntervals(increasing)}<br/>
                <strong>Decreasing Intervals:</strong> ${formatIntervals(decreasing)}<br/>
                <strong>Constant Intervals:</strong> ${formatIntervals(constant)}<br/>
                <br/>
                <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br/>
                <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}<br/>
                <strong>Inflection Points:</strong> ${Array.from(finalInflectionPoints).sort((a,b) => parseFloat(a)-parseFloat(b)).join(', ') || 'None'}
            `;
        }

        degreeSelector.addEventListener("change", () => {
            createSliders(parseInt(degreeSelector.value));
        });
        degreeSelector.value = "4";
        createSliders(parseInt(degreeSelector.value));
    </script>
</body>
</html>
