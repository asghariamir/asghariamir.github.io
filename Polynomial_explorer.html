<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Interactive Polynomial Explorer â€“ Smart Analysis</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        /* Reusing styles from the first app */
        :root{
            --blue:#1565c0;
            --blue-dark:#0d47a1;
            --green:#43a047;
            --orange:#e65100;
            --grey:#bdbdbd;
            --red:#d32f2f;
            --surface:#fff;
            --surface-alt:#f4f4fa;
            --font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;
        }
        html,body{
            margin:0;
            padding:0;
            height:100%;
            font-family:var(--font-family);
            background:var(--surface-alt);
            color:#222;
        }
        .container{
            max-width:1120px;
            margin:20px auto;
            background:var(--surface);
            border-radius:14px;
            box-shadow:0 4px 16px #0000000d;
            padding:1.5rem 2rem;
            display: flex; /* Centering */
            flex-direction: column;
            align-items: center;
        }
        h2{
            margin-top:0;
            color: var(--blue-dark);
            text-align: center;
            width: 100%;
        }
        .main-layout{
            display:flex;
            flex-wrap:wrap;
            gap:2.4rem;
            align-items:flex-start;
            width: 100%;
        }
        .panel{
            flex:1 1 500px;
            min-width:320px;
            background: var(--surface-alt); /* Added consistent background */
            border-radius: 8px; /* Added border-radius */
            padding: 1rem; /* Added padding */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* Added subtle shadow */
        }
        button{
            cursor:pointer;
            border:none;
            border-radius:6px;
            font-size:1em;
            padding:0.5em 1em;
            transition:filter .15s,transform .15s;
            background:var(--blue);
            color:#fff;
        }
        button:hover{filter:brightness(1.1)}
        button:active{transform:scale(0.97)}
        button:disabled{background:#ccc!important;cursor:not-allowed;filter:none}

        input[type="range"], select {
            font-size:inherit;
            padding:0.3em 0.35em;
            border:1px solid #ccc;
            border-radius:4px;
            box-sizing:border-box;
            outline: none;
            transition: border-color 0.15s;
        }
        input[type="range"]:focus, select:focus {
            border-color: var(--blue-dark);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #f0f0f0;
            height: 8px;
            flex-grow: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--blue);
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            transition: background 0.15s, transform 0.15s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--blue-dark);
        }
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(0.95);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--blue);
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            transition: background 0.15s, transform 0.15s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: var(--blue-dark);
        }
        input[type="range"]::-moz-range-thumb:active {
            transform: scale(0.95);
        }

        select {
            width: 100%;
            padding-right: 25px;
            background-color: var(--surface);
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23222" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 5px center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
            border-color: #ccc;
        }
        select:hover { border-color: var(--blue); }

        .controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        .sliders { margin-top: 10px; width: 100%; }
        .slider-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group label { min-width: 150px; text-align: left; }
        .slider-group span { min-width: 30px; text-align: right; font-weight: bold; }

        .info-panel {
            margin-top: 20px;
            background: var(--surface-alt);
            padding: 1.2em;
            border-radius: 8px;
            border: 1px solid #e8eef8;
            font-size: 0.9rem;
            line-height: 1.6;
            width: 100%;
            box-sizing: border-box;
            text-align: left;
        }
        .info-panel h3 {
            margin-top: 0;
            color: var(--blue-dark);
            text-align: center;
        }
        .info-panel strong {
            font-weight: 600;
            color: #333;
        }
        @media(max-width:900px){
            .main-layout{flex-direction:column}
            .panel{flex-basis:auto;width:100%}
        }
        @media(max-width:600px) {
            .container { padding: 1rem; margin: 10px auto; }
            .main-layout { gap: 1.5rem; }
            .controls { flex-direction: column; align-items: flex-start; }
            .slider-group { flex-wrap: wrap; }
            .slider-group label { min-width: unset; width: 100%; }
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>ðŸ§® Interactive Polynomial Explorer</h2>

        <div class="controls">
            <label for="degree">Select polynomial degree (1â€“5): </label>
            <select id="degree">
                <option value="1">1 (Linear)</option>
                <option value="2">2 (Quadratic)</option>
                <option value="3">3 (Cubic)</option>
                <option value="4" selected>4 (Quartic)</option>
                <option value="5">5 (Quintic)</option>
            </select>
        </div>

        <div class="main-layout">
            <div class="panel">
                <div id="sliders" class="sliders"></div>
            </div>
            <div class="panel">
                <div id="plot" style="width: 100%; height: 400px;"></div>
            </div>
        </div>

        <div class="info-panel">
            <h3>ðŸ“Š Polynomial Properties</h3>
            <div id="properties">Add coefficients to begin analysis.</div>
        </div>
    </div>

    <script>
        const slidersDiv = document.getElementById("sliders");
        const degreeSelector = document.getElementById("degree");
        const plotDiv = document.getElementById("plot");
        const propsDiv = document.getElementById("properties");

        let sliders = [];

        const varStr = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
        const epsilon = 1e-6; // Threshold for considering values close to zero

        // Helper function to format powers as superscripts
        function formatPower(base, exponent) {
            if (exponent === 0) return base;
            if (exponent === 1) return base;
            return `${base}<sup>${exponent}</sup>`;
        }

        // Helper function to format expressions with superscripts for display
        function formatExpressionForDisplay(expr) {
            return expr.replace(/x\^(\d+)/g, (match, p1) => {
                const exponent = parseInt(p1);
                if (exponent === 0) return '';
                if (exponent === 1) return 'x';
                return `x<sup>${exponent}</sup>`;
            });
        }

        // Reusable function for formatting intervals
        function formatIntervals(arr) {
            if (arr.length === 0) return 'None';
            arr.sort((a, b) => {
                const startA = a.start === -Infinity ? -Infinity : a.start;
                const startB = b.start === -Infinity ? -Infinity : b.start;
                return startA - startB;
            });

            const mergedIntervals = [];
            if (arr.length > 0) {
                let current = { ...arr[0] };
                for (let i = 1; i < arr.length; i++) {
                    const next = arr[i];
                    const currentEnd = current.end === Infinity ? Infinity : current.end;
                    const nextStart = next.start === -Infinity ? -Infinity : next.start;

                    if (nextStart <= currentEnd + epsilon) {
                        current.end = Math.max(currentEnd, next.end === Infinity ? Infinity : next.end);
                        current.endType = next.endType;
                        if (nextStart === current.start && next.startType === 'open') {
                             current.startType = 'open';
                        }
                    } else {
                        mergedIntervals.push(current);
                        current = { ...next };
                    }
                }
                mergedIntervals.push(current);
            }

            return mergedIntervals.map(i => {
                const openChar = i.startType === 'open' ? '(' : '[';
                const closeChar = i.endType === 'open' ? ')' : ']';
                let startVal = (i.start === -Infinity || i.start === '-Infinity') ? 'âˆ’âˆž' : parseFloat(i.start).toFixed(2);
                let endVal = (i.end === Infinity || i.end === '+Infinity') ? '+âˆž' : parseFloat(i.end).toFixed(2);

                // Fix for -0
                if (parseFloat(startVal) === 0) startVal = '0';
                if (parseFloat(endVal) === 0) endVal = '0';

                return `${openChar}${startVal}, ${endVal}${closeChar}`;
            }).join(' \u222A ');
        }

        function createSliders(degree) {
            slidersDiv.innerHTML = "";
            sliders = [];

            for (let i = degree; i >= 0; i--) {
                const group = document.createElement("div");
                group.className = "slider-group";

                const label = document.createElement("label");
                label.innerHTML = `Coefficient of ${formatPower('x', i)}: `;

                const input = document.createElement("input");
                input.type = "range";
                input.min = -10;
                input.max = 10;
                input.step = 0.1;
                input.value = (i === degree && degree !== 0) ? 1 : 0;
                if (degree === 0) input.value = 1;

                input.dataset.power = i;

                const span = document.createElement("span");
                span.innerText = input.value;

                input.oninput = () => {
                    span.innerText = input.value;
                    updateGraph();
                };

                group.appendChild(label);
                group.appendChild(input);
                group.appendChild(span);
                slidersDiv.appendChild(group);

                sliders.push(input);
            }
            updateGraph();
        }

        function getPolynomialExpr() {
            let terms = sliders.map(s => {
                let coef = parseFloat(s.value);
                let pow = parseInt(s.dataset.power);

                if (Math.abs(coef) < epsilon) return null;

                let termStr;
                if (pow === 0) {
                    termStr = `${coef}`;
                } else if (pow === 1) {
                    if (coef === 1) termStr = `x`;
                    else if (coef === -1) termStr = `-x`;
                    else termStr = `${coef}*x`;
                } else {
                    if (coef === 1) termStr = `x^${pow}`;
                    else if (coef === -1) termStr = `-x^${pow}`;
                    else termStr = `${coef}*x^${pow}`;
                }
                return termStr;
            }).filter(Boolean);

            return terms.length ? terms.join(" + ").replace(/\+ -/g, "- ") : "0";
        }


        function updateGraph() {
            const currentDegree = parseInt(degreeSelector.value);
            const rawExpr = getPolynomialExpr();
            const displayExpr = formatExpressionForDisplay(rawExpr.replace(/\*/g, ''));

            const node = math.parse(rawExpr);
            const f = node.compile();

            if (currentDegree === 0 || rawExpr === "0") {
                 const x_vals_plot = math.range(-10, 10, 0.1).toArray();
                 const y_val = (rawExpr === "0") ? 0 : parseFloat(sliders[0].value);
                 const y_vals_plot = x_vals_plot.map(() => y_val);

                 Plotly.newPlot(plotDiv, [{
                    x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                    line: { color: varStr('--blue') }
                 }], {
                    margin: { t: 50 },
                    title: {
                        text: `f(x) = ${displayExpr}`,
                        y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                        font: { size: 18, family: varStr('--font-family') }
                    },
                    font: { family: varStr('--font-family'), color: '#222' },
                    xaxis: { title: 'x', range: [-10, 10] },
                    yaxis: { title: 'f(x)' }
                 });

                 propsDiv.innerHTML = `
                    <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                    <strong>Increasing Intervals:</strong> None<br/>
                    <strong>Decreasing Intervals:</strong> None<br/>
                    <strong>Constant Intervals:</strong> [âˆ’âˆž, +âˆž]<br/>
                    <br/>
                    <strong>Concave Up:</strong> None<br/>
                    <strong>Concave Down:</strong> None<br/>
                    <strong>Inflection Points:</strong> None
                 `;
                 return;
            }

            const df_node = math.derivative(node, 'x');
            const df = df_node.compile();
            const ddf_node = math.derivative(df_node, 'x');
            const ddf = ddf_node.compile();

            const x_analysis_min = -20;
            const x_analysis_max = 20;
            const x_vals_full = math.range(x_analysis_min, x_analysis_max, 0.005).toArray();
            const dy_vals_full = x_vals_full.map(x => df.evaluate({ x }));
            const ddy_vals_full = x_vals_full.map(x => ddf.evaluate({ x }));

            const x_vals_plot = math.range(-10, 10, 0.1).toArray();
            const y_vals_plot = x_vals_plot.map(x => f.evaluate({x}));


            Plotly.newPlot(plotDiv, [{
                x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                line: { color: varStr('--blue') }
            }], {
                margin: { t: 50 },
                title: {
                    text: `f(x) = ${displayExpr}`,
                    y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                    font: { size: 18, family: varStr('--font-family') }
                },
                font: { family: varStr('--font-family'), color: '#222' },
                xaxis: { title: 'x', range: [-10, 10] },
                yaxis: { title: 'f(x)' }
            });

            const findRoots = (values, xCoords) => {
                const roots = new Set();
                for (let i = 0; i < values.length - 1; i++) {
                    const y1 = values[i];
                    const y2 = values[i+1];
                    const x1 = xCoords[i];
                    const x2 = xCoords[i+1];

                    if ((y1 < -epsilon && y2 > epsilon) ||
                        (y1 > epsilon && y2 < -epsilon) ||
                        (Math.abs(y1) < epsilon && Math.abs(y2) < epsilon && x2 - x1 > epsilon)
                       ) {
                        if (Math.abs(y2 - y1) > epsilon) {
                            const rootX = x1 - y1 * (x2 - x1) / (y2 - y1);
                            roots.add(rootX);
                        } else {
                            roots.add((x1 + x2) / 2);
                        }
                    }
                }
                return Array.from(roots).sort((a,b) => a-b);
            };

            const criticalPoints = findRoots(dy_vals_full, x_vals_full);
            const inflectionCandidates = findRoots(ddy_vals_full, x_vals_full);

            const leadingCoefNode = sliders.find(s => parseInt(s.dataset.power) === currentDegree);
            let leadingCoef_f = leadingCoefNode ? parseFloat(leadingCoefNode.value) : 0;

            let fPrimeEndBehaviorSignAtPosInf = 0;
            let fPrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 0) {
                const f_prime_leading_coef_val = currentDegree * leadingCoef_f;
                if (Math.abs(f_prime_leading_coef_val) > epsilon) {
                    fPrimeEndBehaviorSignAtPosInf = Math.sign(f_prime_leading_coef_val);
                    if ((currentDegree - 1) % 2 !== 0) {
                        fPrimeEndBehaviorSignAtNegInf = -fPrimeEndBehaviorSignAtPosInf;
                    } else {
                        fPrimeEndBehaviorSignAtNegInf = fPrimeEndBehaviorSignAtPosInf;
                    }
                }
            }

            let fDoublePrimeEndBehaviorSignAtPosInf = 0;
            let fDoublePrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 1) {
                const f_double_prime_leading_coef_val = currentDegree * (currentDegree - 1) * leadingCoef_f;
                if (Math.abs(f_double_prime_leading_coef_val) > epsilon) {
                    fDoublePrimeEndBehaviorSignAtPosInf = Math.sign(f_double_prime_leading_coef_val);
                    if ((currentDegree - 2) % 2 !== 0) {
                        fDoublePrimeEndBehaviorSignAtNegInf = -fDoublePrimeEndBehaviorSignAtPosInf;
                    } else {
                        fDoublePrimeEndBehaviorSignAtNegInf = fDoublePrimeEndBehaviorSignAtPosInf;
                    }
                }
            }

            const allAnalysisPoints = Array.from(new Set([...criticalPoints, ...inflectionCandidates]))
                .filter(p => p >= x_analysis_min - epsilon && p <= x_analysis_max + epsilon)
                .sort((a,b) => a-b);

            const increasing = [];
            const decreasing = [];
            const constant = [];
            const concaveUp = [];
            const concaveDown = [];
            const finalInflectionPoints = new Set();

            const getBehaviorSign = (x, derivativeType) => {
                const adjustedX = x;

                if (adjustedX < x_analysis_min - epsilon) {
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtNegInf : fDoublePrimeEndBehaviorSignAtNegInf;
                } else if (adjustedX > x_analysis_max + epsilon) {
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtPosInf : fDoublePrimeEndBehaviorSignAtPosInf;
                } else {
                    try {
                        if (derivativeType === 'first') return Math.sign(df.evaluate({ x: adjustedX }));
                        if (derivativeType === 'second') return Math.sign(ddf.evaluate({ x: adjustedX }));
                    } catch (e) {
                        return 0;
                    }
                }
            };

            let prevPoint = -Infinity;
            const pointsToProcess = [...allAnalysisPoints, Infinity];

            for (const currentPoint of pointsToProcess) {
                if (currentPoint !== Infinity && Math.abs(currentPoint - prevPoint) < epsilon) {
                    continue;
                }

                const intervalStart = prevPoint;
                const intervalEnd = currentPoint;
                let testX;

                if (intervalStart === -Infinity) {
                    testX = (currentPoint === Infinity) ? 0 : currentPoint - 1;
                    if (testX > -epsilon && testX < epsilon) testX = -1;
                    if (testX < x_analysis_min) testX = x_analysis_min - 1;
                } else if (intervalEnd === Infinity) {
                    testX = intervalStart + 1;
                    if (testX > -epsilon && testX < epsilon) testX = 1;
                    if (testX > x_analysis_max) testX = x_analysis_max + 1;
                } else {
                    testX = (intervalStart + intervalEnd) / 2;
                }

                const dy_sign = getBehaviorSign(testX, 'first');
                const ddy_sign = getBehaviorSign(testX, 'second');

                const intervalObj = {
                    start: intervalStart,
                    end: intervalEnd,
                    startType: 'open',
                    endType: 'open'
                };

                if (dy_sign > 0) {
                    increasing.push(intervalObj);
                } else if (dy_sign < 0) {
                    decreasing.push(intervalObj);
                } else {
                    constant.push(intervalObj);
                }

                if (ddy_sign > 0) {
                    concaveUp.push(intervalObj);
                } else if (ddy_sign < 0) {
                    concaveDown.push(intervalObj);
                }

                prevPoint = currentPoint;
            }

            inflectionCandidates.forEach(p => {
                const y_dd_at_p = ddf.evaluate({x:p});
                if (Math.abs(y_dd_at_p) < epsilon) {
                    const sign_left = getBehaviorSign(p - epsilon * 10, 'second');
                    const sign_right = getBehaviorSign(p + epsilon * 10, 'second');
                    if (sign_left !== sign_right && sign_left !== 0 && sign_right !== 0) {
                        finalInflectionPoints.add(p.toFixed(2));
                    }
                }
            });


            propsDiv.innerHTML = `
                <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                <strong>Increasing Intervals:</strong> ${formatIntervals(increasing)}<br/>
                <strong>Decreasing Intervals:</strong> ${formatIntervals(decreasing)}<br/>
                <strong>Constant Intervals:</strong> ${formatIntervals(constant)}<br/>
                <br/>
                <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br/>
                <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}<br/>
                <strong>Inflection Points:</strong> ${Array.from(finalInflectionPoints).sort((a,b) => parseFloat(a)-parseFloat(b)).join(', ') || 'None'}
            `;
        }

        // Initialize
        degreeSelector.addEventListener("change", () => {
            createSliders(parseInt(degreeSelector.value));
        });

        degreeSelector.value = "4";
        createSliders(parseInt(degreeSelector.value));
    </script>
</body>
</html>
