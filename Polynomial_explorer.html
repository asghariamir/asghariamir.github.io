<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Interactive Polynomial Explorer â€“ Smart Analysis</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        /* Replaced color variables with values from the first app */
        :root {
            --blue: #1565c0;
            --blue-dark: #0d47a1;
            --green: #43a047;
            --orange: #e65100;
            --grey: #bdbdbd;
            --red: #d32f2f;
            --surface: #fff;
            --surface-alt: #f4f4fa;
            --shadow: 0 4px 16px #0000000d;
            --shadow-sm: 0 4px 16px #0000000d;
            --radius: 14px;
            --radius-sm: 10px;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: var(--font-family);
            background: var(--surface-alt);
            color: #222;
        }
        .container {
            max-width: 1080px;
            margin: 2rem auto;
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 2.2rem 2.2rem 1.7rem 2.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.6rem;
            border: 1.5px solid #e0e0e0;
        }
        h2 {
            margin-top: 0;
            color: #222;
            font-size: 2.25rem;
            letter-spacing: 0.01em;
            font-weight: 800;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            text-align: center;
            margin-bottom: 0.8rem;
            user-select: none;
        }
        .main-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 2.2rem;
            align-items: stretch;
            width: 100%;
            justify-content: center;
        }
        .panel {
            flex: 1 1 470px;
            min-width: 320px;
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
            transition: box-shadow .22s;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            border: 1.5px solid #e0e0e0;
        }
        .panel:hover {
            box-shadow: var(--shadow);
        }
        /* Controls */
        .controls {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 10px;
            padding: 0.5rem 1.2rem 0.5rem 1.2rem;
            background: #f4f8ff;
            border-radius: var(--radius-sm);
            box-shadow: 0 1px 4px #0000000d;
            border: 1px solid #e8eef8;
        }
        .controls label {
            font-weight: 500;
            letter-spacing: 0.01em;
            margin-right: 0.4em;
        }
        /* Slider Section */
        .sliders {
            margin-top: 10px;
            width: 100%;
        }
        .slider-group {
            margin-bottom: 18px;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the label */
            gap: 0.5em;
        }
        .slider-group label {
            width: 100%;
            font-weight: 500;
            color: #222;
            font-size: 1.01em;
            letter-spacing: 0.01em;
            text-align: center; /* Center the label text */
        }
        /* Wrapper for the slider and value display */
        .slider-control-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
            height: 22px; /* Consistent height */
        }
        /* Range input - Material look */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%; /* Maximize slider width */
            background: #f0f0f0;
            height: 8px;
            border-radius: 6px;
            box-shadow: 0 1px 4px #0000000d;
            outline: none;
            transition: box-shadow 0.18s;
            flex-grow: 1;
            margin: 0;
            padding: 0;
        }
        input[type="range"]:focus {
            box-shadow: 0 2px 8px #0000001a;
        }
        /* Removed original thumb styling */
        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0; /* Hide the default thumb */
            height: 0;
            border: none;
            background: transparent;
        }

        /* Value display as the new "handle" */
        .slider-value-display {
            position: absolute;
            background: var(--blue-dark);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px; /* Slightly rounded corners */
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
            transform: translateX(-50%); /* Center horizontally */
            top: -2px; /* Align with the slider track, adjusted from -20px */
            z-index: 3;
            pointer-events: none; /* Allows clicks/interactions to pass through to slider */
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            min-width: 30px;
            text-align: center;
            height: 22px; /* Same height as the original thumb */
            line-height: 22px; /* Vertically center the text */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        /* Custom Degree Selector Buttons */
        .degree-buttons {
            display: flex;
            gap: 8px;
            margin-left: 8px;
        }
        .degree-button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1.5px solid #ddd;
            border-radius: 7px;
            background: var(--surface);
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 1px 4px #0000000d;
            color: #222;
        }
        .degree-button:hover {
            border-color: #aaa;
            box-shadow: 0 2px 8px #0000001a;
            transform: translateY(-1px);
        }
        .degree-button.active {
            background: var(--blue);
            color: #fff;
            border-color: var(--blue-dark);
            box-shadow: 0 2px 10px #1565c045;
        }
        /* Button */
        button {
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            padding: 0.5em 1em;
            background: var(--green);
            color: #fff;
            font-weight: 600;
            box-shadow: 0 2px 8px #0000000d;
            transition: filter .12s,transform .12s, box-shadow .18s;
        }
        button:hover { filter: brightness(1.1); box-shadow: 0 4px 18px #0000001a;}
        button:active { transform: scale(0.97); }
        button:disabled { background: #ccc !important; cursor: not-allowed; filter: none; }
        /* Plot area */
        #plot {
            width: 100%;
            min-height: 350px;
            background: #fff;
            border-radius: var(--radius-sm);
            border: 1.5px solid #e0e0e0;
            box-shadow: 0 2px 10px #0000000d;
            margin-bottom: 0.2em;
            padding: 0.2em;
        }
        /* Info panel */
        .info-panel {
            margin-top: 22px;
            background: #f8faff;
            padding: 1.4em 2em 1.3em 2em;
            border-radius: var(--radius);
            border: 1.5px solid #e8eef8;
            font-size: 1.01rem;
            line-height: 1.68;
            width: 100%;
            box-sizing: border-box;
            box-shadow: var(--shadow-sm);
            text-align: left;
            letter-spacing: 0.01em;
            color: #222;
        }
        .info-panel h3 {
            margin-top: 0;
            color: #222;
            text-align: center;
            font-size: 1.27em;
            margin-bottom: 0.5em;
            font-weight: 700;
            letter-spacing: 0.02em;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
        }
        .info-panel strong {
            font-weight: 700;
            color: #333;
        }
        /* Badge overlay */
        .rescale-badge {
            position: absolute;
            top: 28px;
            right: 38px;
            background: var(--blue);
            color: #fff;
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1em;
            box-shadow: 0 2px 8px #1565c065;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s;
            z-index: 20;
            letter-spacing: 0.03em;
            user-select: none;
        }
        /* Responsive adjustments */
        @media (max-width: 950px) {
            .main-layout { flex-direction: column; gap: 1.4rem; }
            .panel { flex-basis: auto; min-width: unset; width: 100%; }
        }
        @media (max-width: 600px) {
            .container { padding: 1.2rem 0.3rem 0.6rem 0.3rem; margin: 7px auto; }
            h2 { font-size: 1.45rem; }
            .main-layout { gap: 1.05rem; }
            .controls { flex-direction: column; align-items: stretch; padding: 0.7rem; }
            .panel { padding: 0.85rem 0.6rem; }
            .info-panel { padding: 0.8em 0.5em 1em 0.5em; font-size: 0.99rem;}
            .slider-group label { width: 100%; font-size: 1em; }
            .degree-buttons { width: 100%; justify-content: space-around; }
            .degree-button { width: 35px; height: 35px; font-size: 0.9em; }
            .rescale-badge { top: 10px; right: 10px; font-size: 0.9em; padding: 5px 10px;}
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Interactive Polynomial Explorer</h2>
        <div class="controls">
            <label for="degree">Select polynomial degree: </label>
            <div id="degree-selector-buttons" class="degree-buttons">
            </div>
        </div>
        <div class="main-layout">
            <div class="panel">
                <div id="sliders" class="sliders"></div>
            </div>
            <div class="panel" id="plot-panel" style="position:relative;">
                <div id="plot"></div>
                <div id="rescale-badge" class="rescale-badge">Y-axis rescaled</div>
            </div>
        </div>
        <div class="info-panel">
            <h3> Polynomial Properties</h3>
            <div id="properties">Add coefficients to begin analysis.</div>
        </div>
    </div>
    <script>
        const slidersDiv = document.getElementById("sliders");
        const degreeButtonsContainer = document.getElementById("degree-selector-buttons");
        const plotDiv = document.getElementById("plot");
        const propsDiv = document.getElementById("properties");
        const rescaleBadge = document.getElementById("rescale-badge");

        let sliders = [];
        let currentSelectedDegree = 4;

        const varStr = v => getComputedStyle(document.documentElement).getPropertyValue(v).trim();
        const epsilon = 1e-6;

        function showRescaleBadge() {
            rescaleBadge.style.opacity = '1';
            clearTimeout(showRescaleBadge._timeout);
            showRescaleBadge._timeout = setTimeout(() => {
                rescaleBadge.style.opacity = '0';
            }, 900);
        }

        function formatPower(base, exponent) {
            if (exponent === 0) return base;
            if (exponent === 1) return base;
            return `${base}<sup>${exponent}</sup>`;
        }

        function formatExpressionForDisplay(expr) {
            return expr.replace(/x\^(\d+)/g, (match, p1) => {
                const exponent = parseInt(p1);
                if (exponent === 0) return '';
                if (exponent === 1) return 'x';
                return `x<sup>${exponent}</sup>`;
            });
        }

        function formatIntervals(arr) {
            if (arr.length === 0) return 'None';
            arr.sort((a, b) => {
                const startA = a.start === -Infinity ? -Infinity : a.start;
                const startB = b.start === -Infinity ? -Infinity : b.start;
                return startA - startB;
            });

            const mergedIntervals = [];
            if (arr.length > 0) {
                let current = { ...arr[0] };
                for (let i = 1; i < arr.length; i++) {
                    const next = arr[i];
                    const currentEnd = current.end === Infinity ? Infinity : current.end;
                    const nextStart = next.start === -Infinity ? -Infinity : next.start;

                    if (nextStart <= currentEnd + epsilon) {
                        current.end = Math.max(currentEnd, next.end === Infinity ? Infinity : next.end);
                        current.endType = next.endType;
                        if (nextStart === current.start && next.startType === 'open') {
                             current.startType = 'open';
                        }
                    } else {
                        mergedIntervals.push(current);
                        current = { ...next };
                    }
                }
                mergedIntervals.push(current);
            }

            return mergedIntervals.map(i => {
                const openChar = i.startType === 'open' ? '(' : '[';
                const closeChar = i.endType === 'open' ? ')' : ']';
                let startVal = (i.start === -Infinity || i.start === '-Infinity') ? 'âˆ’âˆž' : parseFloat(i.start).toFixed(2);
                let endVal = (i.end === Infinity || i.end === '+Infinity') ? '+âˆž' : parseFloat(i.end).toFixed(2);

                if (parseFloat(startVal) === 0) startVal = '0';
                if (parseFloat(endVal) === 0) endVal = '0';

                return `${openChar}${startVal}, ${endVal}${closeChar}`;
            }).join(' \u222A ');
        }

        function createDegreeButtons(selectedDegree) {
            degreeButtonsContainer.innerHTML = "";
            for (let i = 1; i <= 5; i++) {
                const button = document.createElement("div");
                button.className = "degree-button";
                button.textContent = i;
                button.dataset.degree = i;

                if (i === selectedDegree) {
                    button.classList.add("active");
                }

                button.addEventListener("click", () => {
                    const currentActive = document.querySelector(".degree-button.active");
                    if (currentActive) {
                        currentActive.classList.remove("active");
                    }
                    button.classList.add("active");
                    currentSelectedDegree = parseInt(button.dataset.degree);
                    createSliders(currentSelectedDegree);
                });
                degreeButtonsContainer.appendChild(button);
            }
        }

        function createSliders(degree) {
            slidersDiv.innerHTML = "";
            sliders = [];

            for (let i = degree; i >= 0; i--) {
                const group = document.createElement("div");
                group.className = "slider-group";

                const label = document.createElement("label");
                label.innerHTML = i === 0 ? 'Constant term:' : `Coefficient of ${formatPower('x', i)}:`;
                group.appendChild(label);

                const controlWrapper = document.createElement("div");
                controlWrapper.className = "slider-control-wrapper";

                const input = document.createElement("input");
                input.type = "range";
                input.min = -10;
                input.max = 10;
                input.step = 0.1;
                input.value = (i === degree && degree !== 0) ? 1 : 0;
                if (degree === 0) input.value = 1;

                input.dataset.power = i;

                const valueDisplay = document.createElement("div");
                valueDisplay.className = "slider-value-display";
                valueDisplay.innerText = input.value;

                const updateValueDisplay = () => {
                    const trackWidth = input.offsetWidth;
                    // Account for the width of the display element itself to truly center it
                    const displayWidth = valueDisplay.offsetWidth; 
                    const value = parseFloat(input.value);
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);

                    const percentage = (value - min) / (max - min);
                    // Calculate offset, subtracting half of the display element's width
                    const offset = percentage * (trackWidth - displayWidth) + displayWidth / 2;

                    valueDisplay.style.left = `${offset}px`;
                    valueDisplay.innerText = input.value;
                };

                input.oninput = () => {
                    updateValueDisplay();
                    updateGraph();
                };

                controlWrapper.appendChild(input);
                controlWrapper.appendChild(valueDisplay);
                group.appendChild(controlWrapper);

                slidersDiv.appendChild(group);
                sliders.push(input);

                // Initial positioning of the value display after elements are in DOM
                // Also trigger update on load if a slider isn't at min/max initially
                setTimeout(updateValueDisplay, 0); 
            }
            updateGraph();
        }

        function getPolynomialExpr() {
            let terms = sliders.map(s => {
                let coef = parseFloat(s.value);
                let pow = parseInt(s.dataset.power);

                if (Math.abs(coef) < epsilon) return null;

                let termStr;
                if (pow === 0) {
                    termStr = `${coef}`;
                } else if (pow === 1) {
                    if (coef === 1) termStr = 'x';
                    else if (coef === -1) termStr = '-x';
                    else termStr = `${coef}*x`;
                } else {
                    if (coef === 1) termStr = `x^${pow}`;
                    else if (coef === -1) termStr = `-x^${pow}`;
                    else termStr = `${coef}*x^${pow}`;
                }
                return termStr;
            }).filter(Boolean);

            return terms.length ? terms.join(" + ").replace(/\+ -/g, "- ") : "0";
        }

        function bisectionMethod(func, a, b, tolerance = 1e-9, maxIterations = 100) {
            let fa = func.evaluate({ x: a });
            let fb = func.evaluate({ x: b });

            if (fa * fb > 0 && Math.abs(fa) > tolerance && Math.abs(fb) > tolerance) {
                return [];
            }

            let c;
            for (let i = 0; i < maxIterations; i++) {
                c = (a + b) / 2;
                let fc = func.evaluate({ x: c });

                if (Math.abs(fc) < tolerance || (b - a) / 2 < tolerance) {
                    return [c];
                }

                if (fa * fc < 0) {
                    b = c;
                    fb = fc;
                } else {
                    a = c;
                    fa = fc;
                }
            }
            return [c];
        }

        function updateGraph() {
            const currentDegree = currentSelectedDegree;
            const rawExpr = getPolynomialExpr();
            const displayExpr = formatExpressionForDisplay(rawExpr.replace(/\*/g, ''));

            const node = math.parse(rawExpr);
            const f = node.compile();

            if (currentDegree === 0 || rawExpr === "0") {
                const x_vals_plot = math.range(-10, 10, 0.1).toArray();
                const y_val = (rawExpr === "0") ? 0 : parseFloat(sliders[0].value);
                const y_vals_plot = x_vals_plot.map(() => y_val);

                Plotly.react(plotDiv, [{
                    x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                    line: { color: varStr('--blue') }
                }], {
                    margin: { t: 50 },
                    title: {
                        text: `f(x) = ${displayExpr}`,
                        y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                        font: { size: 18, family: varStr('--font-family') }
                    },
                    font: { family: varStr('--font-family'), color: '#222' },
                    xaxis: { title: 'x', range: [-10, 10] },
                    yaxis: { title: 'f(x)', range: [-10, 10] }
                }, {responsive:true, animate: true});

                propsDiv.innerHTML = `
                    <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                    <strong>Increasing Intervals:</strong> None<br/>
                    <strong>Decreasing Intervals:</strong> None<br/>
                    <strong>Constant Intervals:</strong> [âˆ’âˆž, +âˆž]<br/>
                    <br/>
                    <strong>Concave Up:</strong> None<br/>
                    <strong>Concave Down:</strong> None<br/>
                    <strong>Inflection Points:</strong> None
                `;
                return;
            }

            const df_node = math.derivative(node, 'x');
            const df = df_node.compile();
            const ddf_node = math.derivative(df_node, 'x');
            const ddf = ddf_node.compile();

            const x_analysis_min = -20;
            const x_analysis_max = 20;
            const x_vals_full = math.range(x_analysis_min, x_analysis_max, 0.001).toArray();
            const dy_vals_full = x_vals_full.map(x => df.evaluate({ x }));
            const ddy_vals_full = x_vals_full.map(x => ddf.evaluate({ x }));

            const x_vals_plot = math.range(-10, 10, 0.1).toArray();
            const y_vals_plot = x_vals_plot.map(x => f.evaluate({x}));

            const minY = Math.min(...y_vals_plot);
            const maxY = Math.max(...y_vals_plot);

            let yMin = Math.max(minY, -1000);
            let yMax = Math.min(maxY, 1000);

            if (Math.abs(yMax - yMin) < 1e-3) {
                yMin -= 1;
                yMax += 1;
            }

            if (typeof updateGraph.prevYMin !== 'undefined') {
                if (Math.abs(updateGraph.prevYMin - yMin) > 0.2 || Math.abs(updateGraph.prevYMax - yMax) > 0.2) {
                    showRescaleBadge();
                }
            }
            updateGraph.prevYMin = yMin;
            updateGraph.prevYMax = yMax;

            Plotly.react(plotDiv, [{
                x: x_vals_plot, y: y_vals_plot, mode: 'lines', name: 'f(x)',
                line: { color: varStr('--blue') }
            }], {
                margin: { t: 50 },
                title: {
                    text: `f(x) = ${displayExpr}`,
                    y: 0.95, x: 0.5, xanchor: 'center', yanchor: 'top',
                    font: { size: 18, family: varStr('--font-family') }
                },
                font: { family: varStr('--font-family'), color: '#222' },
                xaxis: { title: 'x', range: [-10, 10] },
                yaxis: { title: 'f(x)', range: [yMin, yMax] }
            }, {responsive:true, animate: true});

            const findRoots = (func, xCoords) => {
                const roots = new Set();
                const bisectionTolerance = 1e-8;

                for (let i = 0; i < xCoords.length - 1; i++) {
                    const x1 = xCoords[i];
                    const x2 = xCoords[i+1];
                    const y1 = func.evaluate({ x: x1 });
                    const y2 = func.evaluate({ x: x2 });

                    if ((y1 < -epsilon && y2 > epsilon) || (y1 > epsilon && y2 < -epsilon)) {
                        const foundRoot = bisectionMethod(func, x1, x2, bisectionTolerance);
                        foundRoot.forEach(root => roots.add(root));
                    } else if (Math.abs(y1) < epsilon) {
                        roots.add(x1);
                    }
                }
                if (Math.abs(func.evaluate({ x: xCoords[xCoords.length - 1] })) < epsilon) {
                    roots.add(xCoords[xCoords.length - 1]);
                }

                return Array.from(roots).sort((a,b) => a-b);
            };

            const criticalPoints = findRoots(df_node, x_vals_full);
            const inflectionCandidates = findRoots(ddf_node, x_vals_full);

            const leadingCoefNode = sliders.find(s => parseInt(s.dataset.power) === currentDegree);
            let leadingCoef_f = leadingCoefNode ? parseFloat(leadingCoefNode.value) : 0;

            let fPrimeEndBehaviorSignAtPosInf = 0;
            let fPrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 0) {
                const f_prime_leading_coef_val = currentDegree * leadingCoef_f;
                if (Math.abs(f_prime_leading_coef_val) > epsilon) {
                    fPrimeEndBehaviorSignAtPosInf = Math.sign(f_prime_leading_coef_val);
                    if ((currentDegree - 1) % 2 !== 0) {
                        fPrimeEndBehaviorSignAtNegInf = -fPrimeEndBehaviorSignAtPosInf;
                    } else {
                        fPrimeEndBehaviorSignAtNegInf = fPrimeEndBehaviorSignAtPosInf;
                    }
                }
            }

            let fDoublePrimeEndBehaviorSignAtPosInf = 0;
            let fDoublePrimeEndBehaviorSignAtNegInf = 0;
            if (currentDegree > 1) {
                const f_double_prime_leading_coef_val = currentDegree * (currentDegree - 1) * leadingCoef_f;
                if (Math.abs(f_double_prime_leading_coef_val) > epsilon) {
                    fDoublePrimeEndBehaviorSignAtPosInf = Math.sign(f_double_prime_leading_coef_val);
                    if ((currentDegree - 2) % 2 !== 0) {
                        fDoublePrimeEndBehaviorSignAtNegInf = -fDoublePrimeEndBehaviorSignAtPosInf;
                    } else {
                        fDoublePrimeEndBehaviorSignAtNegInf = fDoublePrimeEndBehaviorSignAtPosInf;
                    }
                }
            }

            const allAnalysisPoints = Array.from(new Set([...criticalPoints, ...inflectionCandidates]))
                .filter(p => p >= x_analysis_min - epsilon && p <= x_analysis_max + epsilon)
                .sort((a,b) => a-b);

            const increasing = [];
            const decreasing = [];
            const constant = [];
            const concaveUp = [];
            const concaveDown = [];
            const finalInflectionPoints = new Set();

            const getBehaviorSign = (x, derivativeType) => {
                const adjustedX = x;

                if (adjustedX < x_analysis_min - epsilon) {
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtNegInf : fDoublePrimeEndBehaviorSignAtNegInf;
                } else if (adjustedX > x_analysis_max + epsilon) {
                    return derivativeType === 'first' ? fPrimeEndBehaviorSignAtPosInf : fDoublePrimeEndBehaviorSignAtPosInf;
                } else {
                    try {
                        if (derivativeType === 'first') return Math.sign(df.evaluate({ x: adjustedX }));
                        if (derivativeType === 'second') return Math.sign(ddf.evaluate({ x: adjustedX }));
                    } catch (e) {
                        return 0;
                    }
                }
            };

            let prevPoint = -Infinity;
            const pointsToProcess = [...allAnalysisPoints, Infinity];

            for (const currentPoint of pointsToProcess) {
                if (currentPoint !== Infinity && Math.abs(currentPoint - prevPoint) < epsilon) {
                    continue;
                }

                const intervalStart = prevPoint;
                const intervalEnd = currentPoint;
                let testX;

                if (intervalStart === -Infinity) {
                    testX = (currentPoint === Infinity) ? 0 : currentPoint - 1;
                    if (testX > -epsilon && testX < epsilon) testX = -1;
                    if (testX < x_analysis_min) testX = x_analysis_min - 1;
                } else if (intervalEnd === Infinity) {
                    testX = intervalStart + 1;
                    if (testX > -epsilon && testX < epsilon) testX = 1;
                    if (testX > x_analysis_max) testX = x_analysis_max + 1;
                } else {
                    testX = (intervalStart + intervalEnd) / 2;
                }

                const dy_sign = getBehaviorSign(testX, 'first');
                const ddy_sign = getBehaviorSign(testX, 'second');

                const intervalObj = {
                    start: intervalStart,
                    end: intervalEnd,
                    startType: 'open',
                    endType: 'open'
                };

                if (dy_sign > 0) {
                    increasing.push(intervalObj);
                } else if (dy_sign < 0) {
                    decreasing.push(intervalObj);
                } else {
                    constant.push(intervalObj);
                }

                if (ddy_sign > 0) {
                    concaveUp.push(intervalObj);
                } else if (ddy_sign < 0) {
                    concaveDown.push(intervalObj);
                }

                prevPoint = currentPoint;
            }

            inflectionCandidates.forEach(p => {
                const y_dd_at_p = ddf.evaluate({x:p});
                if (Math.abs(y_dd_at_p) < epsilon) {
                    const sign_left = getBehaviorSign(p - epsilon * 10, 'second');
                    const sign_right = getBehaviorSign(p + epsilon * 10, 'second');
                    if (sign_left !== sign_right && sign_left !== 0 && sign_right !== 0) {
                        finalInflectionPoints.add(p.toFixed(2));
                    }
                }
            });

            propsDiv.innerHTML = `
                <strong>Function:</strong> f(x) = ${displayExpr}<br/><br/>
                <strong>Increasing Intervals:</strong> ${formatIntervals(increasing)}<br/>
                <strong>Decreasing Intervals:</strong> ${formatIntervals(decreasing)}<br/>
                <strong>Constant Intervals:</strong> ${formatIntervals(constant)}<br/>
                <br/>
                <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br/>
                <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}<br/>
                <strong>Inflection Points:</strong> ${Array.from(finalInflectionPoints).sort((a,b) => parseFloat(a)-parseFloat(b)).join(', ') || 'None'}
            `;
        }

        document.addEventListener("DOMContentLoaded", () => {
            // Ensure degree buttons are created and currentSelectedDegree is set
            createDegreeButtons(currentSelectedDegree); 
            // Then, create sliders based on the (now correctly set) default degree
            createSliders(currentSelectedDegree); 
            
            // Re-calculate slider value positions on window resize
            window.addEventListener('resize', () => {
                sliders.forEach(slider => {
                    const valueDisplay = slider.parentElement.querySelector('.slider-value-display');
                    if (valueDisplay) {
                        const trackWidth = slider.offsetWidth;
                        const displayWidth = valueDisplay.offsetWidth; 
                        const value = parseFloat(slider.value);
                        const min = parseFloat(slider.min);
                        const max = parseFloat(slider.max);
                        const percentage = (value - min) / (max - min);
                        const offset = percentage * (trackWidth - displayWidth) + displayWidth / 2;
                        valueDisplay.style.left = `${offset}px`;
                    }
                });
            });
        });
    </script>
</body>
</html>
