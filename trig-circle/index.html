<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trigonometry Explorer | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <style>
        /* Root variables - Mathswell color palette */
        :root {
            --primary: #0f766e;       /* Mathswell teal */
            --primary-light: #10b981;  /* Light teal */
            --background: #f7faf9;     /* Very light gray-green */
            --interactive: #e6fffb;    /* Light teal bg */
            --text-primary: #212121;   /* Dark gray */
            --text-muted: #4b5563;     /* Muted text */
            --accent-amber: #f59e0b;   /* Use sparingly */
            --accent-red: #c62828;     /* For sine lines */
            --accent-blue: #1565c0;    /* For cosine lines */
            --accent-purple: #6a1b9a;  /* For tangent lines */
            --success: #10b981;        /* Correct answers */
        }
        
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            padding-top: 60px;
            line-height: 1.5;
        }
        
        /* CENTERED Mathswell Navigation */
        .mathswell-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            border-bottom: 2px solid var(--primary);
            padding: 0.75rem 1rem;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .mw-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--primary);
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        /* Container */
        .container {
            max-width: 1000px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        /* CENTERED Tab Navigation */
        .tabs {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            background: white;
            padding: 0.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }
        
        .tab-btn.active {
            background: var(--primary);
            color: white;
        }
        
        .tab-btn:hover:not(.active) {
            background: var(--interactive);
            color: var(--primary);
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Section headers */
        h2 {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        /* Intro boxes */
        .intro {
            background: var(--interactive);
            border: 1px solid var(--primary-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
        }
        
        .intro h3 {
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .intro p {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        /* Canvas styling */
        canvas {
            background: white;
            border: 2px solid var(--primary-light);
            border-radius: 8px;
            touch-action: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            transition: box-shadow 0.2s ease;
            display: block;
            margin: 1rem auto;
        }
        
        canvas:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        /* Output display */
        .output {
            margin-top: 1rem;
            font-family: 'Monaco', 'Courier New', monospace;
            background: var(--interactive);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--primary);
            font-size: 0.9rem;
        }
        
        /* Pills */
        .pills {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .pill {
            padding: 0.4rem 1rem;
            border: 2px solid var(--primary);
            border-radius: 999px;
            font-size: 0.9rem;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 500;
            background: white;
            color: var(--primary);
        }
        
        .pill:hover {
            background: var(--interactive);
            transform: translateY(-2px);
        }
        
        .pill.active {
            background: var(--primary);
            color: white;
        }
        
        /* Identity pills for Unit Circle */
        .identity-pills {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .identity-pill {
            padding: 0.3rem 0.8rem;
            border: 2px solid var(--primary-light);
            border-radius: 999px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            color: var(--primary);
            font-family: 'Monaco', 'Courier New', monospace;
        }
        
        .identity-pill:hover {
            background: var(--interactive);
            transform: translateY(-2px);
        }
        
        .identity-pill.active {
            background: var(--primary-light);
            color: white;
        }
        
        /* Slider styling */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1rem auto;
            max-width: 440px;
            background: var(--interactive);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--primary-light);
        }
        
        label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        input[type="range"] {
            appearance: none;
            background: transparent;
            cursor: pointer;
            flex: 1;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: var(--primary-light);
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-track {
            background: var(--primary-light);
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .angle-value {
            font-family: 'Monaco', 'Courier New', monospace;
            min-width: 80px;
            text-align: right;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        /* Select styling */
        select {
            padding: 0.5rem 1rem;
            border: 2px solid var(--primary);
            border-radius: 8px;
            background: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--primary);
        }
        
        select:hover {
            background: var(--interactive);
        }
        
        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(15, 118, 110, 0.1);
        }
        
        /* Checkbox */
        input[type="checkbox"] {
            accent-color: var(--primary);
            transform: scale(1.1);
        }
        
        .checkbox-container {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--interactive);
            border-radius: 8px;
            border: 1px solid var(--primary-light);
            text-align: center;
        }
        
        /* Canvas group */
        .canvas-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
            justify-content: center;
        }
        
        .deg-rad-container {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* Lock button for Unit Circle */
        .lock-container {
            text-align: center;
            margin: 1rem 0;
        }
        
        .lock-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .lock-btn:hover {
            background: var(--primary-light);
            transform: translateY(-1px);
        }
        
        .lock-btn.locked {
            background: var(--accent-amber);
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .tab-btn {
                font-size: 0.85rem;
                padding: 0.6rem 1rem;
            }
            
            .canvas-group {
                flex-direction: column;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Centered Mathswell Navigation -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <!-- Centered Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="triangle">Triangle</button>
            <button class="tab-btn" data-tab="unit">Unit Circle</button>
            <button class="tab-btn" data-tab="degrees">Deg â†” Rad</button>
            <button class="tab-btn" data-tab="graph">Graph</button>
        </div>
        
        <!-- Triangle Tab -->
        <div id="triangle" class="tab-content active">
            <h2>Right Triangle</h2>
            <div class="intro">
                <h3>Fundamental Trigonometric Ratios</h3>
                <p>This tab explores the fundamental trigonometric ratios (sine, cosine, tangent) in the context of a right-angled triangle.</p>
                <p><strong>How to use:</strong> Drag the slider to change the angle of interest and observe how the side lengths and their ratios change.</p>
            </div>
            <canvas id="triCanvas" width="440" height="320"></canvas>
            <div class="slider-container">
                <label for="angleSlider">Angle:</label>
                <input type="range" id="angleSlider" min="0" max="90" step="0.1">
                <span id="angleValue" class="angle-value"></span>
            </div>
            <div id="triOutput" class="output"></div>
        </div>
        
        <!-- Unit Circle Tab -->
        <div id="unit" class="tab-content">
            <h2>Unit Circle</h2>
            <div class="intro">
                <h3>Beyond Right-Angled Triangles</h3>
                <p>The Unit Circle extends trigonometry to any angle. Explore trigonometric identities by locking an angle and comparing it with related angles.</p>
                <p><strong>How to use:</strong> Drag the point on the circle or wheel. Lock an angle, then explore identities like sin(-Î¸), cos(Ï€/2 + Î¸), and more!</p>
            </div>
            
            <div class="pills" id="ratios">
                <span class="pill active" data-r="sin">sin</span>
                <span class="pill" data-r="cos">cos</span>
                <span class="pill" data-r="tan">tan</span>
            </div>
            
            <div class="lock-container">
                <button id="lockBtn" class="lock-btn">ðŸ”“ Lock Current Angle</button>
            </div>
            
            <div class="identity-pills" id="identities">
                <span class="identity-pill" data-transform="original">Î¸</span>
                <span class="identity-pill" data-transform="negative">-Î¸</span>
                <span class="identity-pill" data-transform="pi-minus">Ï€ - Î¸</span>
                <span class="identity-pill" data-transform="pi-plus">Ï€ + Î¸</span>
                <span class="identity-pill" data-transform="half-pi-plus">Ï€/2 + Î¸</span>
                <span class="identity-pill" data-transform="half-pi-minus">Ï€/2 - Î¸</span>
                <span class="identity-pill" data-transform="two-pi-minus">2Ï€ - Î¸</span>
            </div>
            
            <canvas id="unitCanvas" width="420" height="420"></canvas>
            <canvas id="wheelCanvas" width="120" height="120"></canvas>
            <div id="unitOutput" class="output"></div>
        </div>
        
        <!-- Degrees â†” Radians Tab -->
        <div id="degrees" class="tab-content">
            <h2>Degrees â†” Radians</h2>
            <div class="intro">
                <h3>Two Units for Measuring Angles</h3>
                <p>This tab helps visualize the relationship between Degrees and Radians. An angle of Ï€ radians equals 180Â°.</p>
                <p><strong>How to use:</strong> Drag the point on either circle. Use the checkbox to switch between counter-clockwise (positive) and clockwise (negative) angles.</p>
            </div>
            <div class="checkbox-container">
                <label><input type="checkbox" id="negCheck"> Use clockwise (negative) angles</label>
            </div>
            <div class="deg-rad-container">
                <canvas id="degCanvas" width="350" height="350"></canvas>
                <canvas id="radCanvas" width="350" height="350"></canvas>
            </div>
        </div>
        
        <!-- Graph Tab -->
        <div id="graph" class="tab-content">
            <h2>Graph</h2>
            <div class="intro">
                <h3>From Circle to Wave Functions</h3>
                <p>See how trigonometric values from the unit circle unfold into continuous wave functions.</p>
                <p><strong>How to use:</strong> Select a function and drag the point on the unit circle to see its corresponding position on the graph.</p>
            </div>
            <select id="graphFunc">
                <option value="sin">sin</option>
                <option value="cos">cos</option>
                <option value="tan">tan</option>
            </select>
            <div class="canvas-group">
                <canvas id="graphUnitCircle" width="310" height="310"></canvas>
                <canvas id="graphPlot" width="640" height="320"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        // Shared helpers
        const TAU = Math.PI * 2;
        const SNAP = 0.04;
        const COMMON_ANGLES = [...Array(24)].map((_, i) => i * Math.PI / 12);
        let angle = Math.PI / 6; // Global shared angle state
        
        const $ = s => document.querySelector(s);
        const $$ = s => [...document.querySelectorAll(s)];
        
        const snap = a => {
            const found = COMMON_ANGLES.find(c => Math.abs(a - c) < SNAP);
            return found !== undefined ? found : a;
        };
        
        const clear = ctx => ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        const circle = (ctx, x, y, r) => {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, TAU);
            ctx.stroke();
        };
        
        const renders = {};
        const updateAll = () => Object.values(renders).forEach(f => f());
        
        // Tab switching
        $$('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                $$('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                $$('.tab-content').forEach(c => c.classList.remove('active'));
                $(`#${btn.dataset.tab}`).classList.add('active');
            });
        });
        
        // Triangle Tab
        (() => {
            const canvas = $('#triCanvas');
            const ctx = canvas.getContext('2d');
            const base = { x: 40, y: canvas.height - 20 };
            const diam = 360;
            const R = diam / 2;
            const center = { x: base.x + R, y: base.y };
            const slider = $('#angleSlider');
            const angleValueSpan = $('#angleValue');
            
            const point = a => ({
                x: center.x + R * Math.cos(Math.PI - a),
                y: center.y - R * Math.sin(Math.PI - a)
            });
            
            function protractor() {
                ctx.strokeStyle = 'rgba(15, 118, 110, 0.2)';
                for (let d = 0; d <= 90; d += 10) {
                    const a = d * Math.PI / 180;
                    ctx.beginPath();
                    ctx.moveTo(base.x, base.y);
                    ctx.lineTo(base.x + 40 * Math.cos(a), base.y - 40 * Math.sin(a));
                    ctx.stroke();
                }
                ctx.strokeStyle = '#000';
            }
            
            function draw() {
                clear(ctx);
                const p = point(((angle % TAU) + TAU) % Math.PI);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(base.x, base.y);
                ctx.lineTo(p.x, p.y);
                ctx.lineTo(base.x + diam, base.y);
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = '#0f766e';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, TAU);
                ctx.fill();
                
                protractor();
                
                const cornerAngleRad = angle / 2;
                const targetAngleRad = (Math.PI / 2) - cornerAngleRad;
                const targetAngleDeg = (targetAngleRad * 180 / Math.PI).toFixed(1);
                
                $('#triOutput').innerHTML = `sin(${targetAngleDeg}Â°) = ${Math.sin(targetAngleRad).toFixed(3)}<br>` +
                    `cos(${targetAngleDeg}Â°) = ${Math.cos(targetAngleRad).toFixed(3)}<br>` +
                    `tan(${targetAngleDeg}Â°) = ${Math.tan(targetAngleRad).toFixed(3)}`;
                
                angleValueSpan.textContent = `${targetAngleDeg}Â°`;
            }
            
            function setup() {
                const initialCornerAngleRad = angle / 2;
                const initialTargetAngleRad = (Math.PI / 2) - initialCornerAngleRad;
                const initialTargetAngleDeg = initialTargetAngleRad * 180 / Math.PI;
                slider.value = initialTargetAngleDeg;
                draw();
            }
            
            slider.addEventListener('input', () => {
                const targetAngleDeg = parseFloat(slider.value);
                const targetAngleRad = targetAngleDeg * Math.PI / 180;
                const cornerAngleRad = (Math.PI / 2) - targetAngleRad;
                angle = 2 * cornerAngleRad;
                draw();
                updateAll();
            });
            
            renders.tri = setup;
            setup();
        })();
        
        // Unit Circle Tab with Identity Explorer
        (() => {
            const canvas = $('#unitCanvas');
            const ctx = canvas.getContext('2d');
            const wheel = $('#wheelCanvas');
            const wctx = wheel.getContext('2d');
            const cx = canvas.width / 2;
            const r = cx - 40;
            let dragging = false;
            let dragCanvas = null;
            let prevRaw = 0;
            let lockedAngle = null;
            let currentTransform = 'original';
            
            const pills = $$('#ratios .pill');
            const active = new Set(['sin']);
            const lockBtn = $('#lockBtn');
            const identityPills = $$('#identities .identity-pill');
            
            // Format angle in radians as a nice fraction
            function formatRadians(rad) {
                // Handle negative angles
                const isNegative = rad < -0.01;
                const absRad = Math.abs(rad);
                
                // Normalize to [0, 2Ï€)
                const normalized = ((absRad % TAU) + TAU) % TAU;
                const piMultiple = normalized / Math.PI;
                
                // Check for common fractions with correct values
                const fractions = [
                    [0, '0'],
                    [1/6, 'Ï€/6'],     // 30Â°
                    [1/4, 'Ï€/4'],     // 45Â°
                    [1/3, 'Ï€/3'],     // 60Â°
                    [1/2, 'Ï€/2'],     // 90Â°
                    [2/3, '2Ï€/3'],    // 120Â°
                    [3/4, '3Ï€/4'],    // 135Â°
                    [5/6, '5Ï€/6'],    // 150Â°
                    [1, 'Ï€'],         // 180Â°
                    [7/6, '7Ï€/6'],    // 210Â°
                    [5/4, '5Ï€/4'],    // 225Â°
                    [4/3, '4Ï€/3'],    // 240Â°
                    [3/2, '3Ï€/2'],    // 270Â°
                    [5/3, '5Ï€/3'],    // 300Â°
                    [7/4, '7Ï€/4'],    // 315Â°
                    [11/6, '11Ï€/6'],  // 330Â°
                    [2, '2Ï€']         // 360Â°
                ];
                
                for (let [val, str] of fractions) {
                    if (Math.abs(piMultiple - val) < 0.01) {
                        if (isNegative && str !== '0') {
                            return '-' + str;
                        }
                        return str;
                    }
                }
                
                // Not a common fraction
                const result = `${piMultiple.toFixed(2)}Ï€`;
                return isNegative ? '-' + result : result;
            }
            
            // Get exact values for famous angles
            function getExactValue(func, angleRad) {
                const eps = 0.01;
                // Normalize to [0, 2Ï€)
                let norm = angleRad % TAU;
                if (norm < 0) norm += TAU;
                
                // Get the actual numeric value
                const actualValue = { sin: Math.sin, cos: Math.cos, tan: Math.tan }[func](angleRad);
                
                // Special cases first
                if (Math.abs(actualValue) < eps) return '0';
                if (Math.abs(actualValue - 1) < eps) return '1';
                if (Math.abs(actualValue + 1) < eps) return '-1';
                
                // For tan at Ï€/2 and 3Ï€/2
                if (func === 'tan' && (Math.abs(norm - Math.PI/2) < eps || Math.abs(norm - 3*Math.PI/2) < eps)) {
                    return 'undefined';
                }
                
                // Check reference angle (always positive, between 0 and Ï€/2)
                let refAngle;
                if (norm <= Math.PI/2) {
                    refAngle = norm;
                } else if (norm <= Math.PI) {
                    refAngle = Math.PI - norm;
                } else if (norm <= 3*Math.PI/2) {
                    refAngle = norm - Math.PI;
                } else {
                    refAngle = TAU - norm;
                }
                refAngle = Math.abs(refAngle);
                
                // Check if it's a famous angle
                let baseValue = null;
                
                if (Math.abs(refAngle - Math.PI/6) < eps) {
                    // 30Â° reference
                    if (func === 'sin') baseValue = '1/2';
                    else if (func === 'cos') baseValue = 'âˆš3/2';
                    else if (func === 'tan') baseValue = '1/âˆš3';
                } else if (Math.abs(refAngle - Math.PI/4) < eps) {
                    // 45Â° reference
                    if (func === 'sin') baseValue = 'âˆš2/2';
                    else if (func === 'cos') baseValue = 'âˆš2/2';
                    else if (func === 'tan') baseValue = '1';
                } else if (Math.abs(refAngle - Math.PI/3) < eps) {
                    // 60Â° reference
                    if (func === 'sin') baseValue = 'âˆš3/2';
                    else if (func === 'cos') baseValue = '1/2';
                    else if (func === 'tan') baseValue = 'âˆš3';
                }
                
                if (baseValue !== null) {
                    // Apply sign based on actual value
                    if (actualValue < -eps) {
                        return '-' + baseValue;
                    } else {
                        return baseValue;
                    }
                }
                
                // Not a famous angle, return decimal
                return actualValue.toFixed(3);
            }
            
            // Format the transformation expression
            function getTransformExpression() {
                if (!lockedAngle || currentTransform === 'original') return '';
                
                const lockedRad = formatRadians(lockedAngle);
                
                let expression = '';
                switch (currentTransform) {
                    case 'negative':
                        expression = `-${lockedRad}`;
                        if (lockedRad === '0') expression = '0';
                        break;
                    case 'pi-minus':
                        expression = `Ï€ - ${lockedRad}`;
                        break;
                    case 'pi-plus':
                        expression = `Ï€ + ${lockedRad}`;
                        break;
                    case 'half-pi-plus':
                        expression = `Ï€/2 + ${lockedRad}`;
                        break;
                    case 'half-pi-minus':
                        expression = `Ï€/2 - ${lockedRad}`;
                        break;
                    case 'two-pi-minus':
                        expression = `2Ï€ - ${lockedRad}`;
                        break;
                }
                
                return expression;
            }
            
            pills.forEach(p => p.onclick = () => {
                p.classList.toggle('active');
                if (p.classList.contains('active')) {
                    active.add(p.dataset.r);
                } else {
                    active.delete(p.dataset.r);
                }
                draw();
            });
            
            // Lock/unlock functionality
            lockBtn.onclick = () => {
                if (lockedAngle === null) {
                    lockedAngle = angle;
                    lockBtn.textContent = 'ðŸ”’ Unlock Angle';
                    lockBtn.classList.add('locked');
                    identityPills[0].click(); // Reset to original
                } else {
                    lockedAngle = null;
                    lockBtn.textContent = 'ðŸ”“ Lock Current Angle';
                    lockBtn.classList.remove('locked');
                    currentTransform = 'original';
                    identityPills.forEach(p => p.classList.remove('active'));
                }
                draw();
            };
            
            // Identity transformation
            identityPills.forEach(pill => {
                pill.onclick = () => {
                    if (lockedAngle === null) return;
                    
                    identityPills.forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');
                    currentTransform = pill.dataset.transform;
                    
                    // Apply transformation
                    switch (currentTransform) {
                        case 'original':
                            angle = lockedAngle;
                            break;
                        case 'negative':
                            angle = -lockedAngle;
                            break;
                        case 'pi-minus':
                            angle = Math.PI - lockedAngle;
                            break;
                        case 'pi-plus':
                            angle = Math.PI + lockedAngle;
                            break;
                        case 'half-pi-plus':
                            angle = Math.PI/2 + lockedAngle;
                            break;
                        case 'half-pi-minus':
                            angle = Math.PI/2 - lockedAngle;
                            break;
                        case 'two-pi-minus':
                            angle = TAU - lockedAngle;
                            break;
                    }
                    draw();
                    updateAll();
                };
            });
            
            function drawWheel() {
                const c = wheel.width / 2;
                const R = c - 10;
                clear(wctx);
                
                const pa = ((angle % TAU) + TAU) % TAU;
                wctx.fillStyle = 'rgba(15, 118, 110, 0.25)';
                wctx.beginPath();
                wctx.moveTo(c, c);
                wctx.arc(c, c, R, 0, -pa, true);
                wctx.closePath();
                wctx.fill();
                
                wctx.strokeStyle = '#0f766e';
                wctx.lineWidth = 2;
                circle(wctx, c, c, R);
                
                wctx.fillStyle = '#0f766e';
                wctx.beginPath();
                wctx.arc(c + R * Math.cos(angle), c - R * Math.sin(angle), 4, 0, TAU);
                wctx.fill();
            }
            
            function draw() {
                clear(ctx);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#000';
                circle(ctx, cx, cx, r);
                
                // Axes
                ctx.strokeStyle = '#bbb';
                ctx.beginPath();
                ctx.moveTo(cx - r - 30, cx);
                ctx.lineTo(cx + r + 30, cx);
                ctx.moveTo(cx, cx - r - 30);
                ctx.lineTo(cx, cx + r + 30);
                ctx.stroke();
                
                ctx.font = '16px sans-serif';
                ctx.fillStyle = '#222';
                ctx.textAlign = 'right';
                ctx.fillText('cos', cx + r + 28, cx + 5);
                ctx.textAlign = 'center';
                ctx.fillText('sin', cx - 5, cx - r - 12);
                
                // Draw locked angle reference if exists
                if (lockedAngle !== null) {
                    const lx = cx + r * Math.cos(lockedAngle);
                    const ly = cx - r * Math.sin(lockedAngle);
                    
                    ctx.strokeStyle = 'rgba(245, 158, 11, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(cx, cx);
                    ctx.lineTo(lx, ly);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = 'rgba(245, 158, 11, 0.5)';
                    ctx.beginPath();
                    ctx.arc(lx, ly, 4, 0, TAU);
                    ctx.fill();
                }
                
                // Current point
                const px = cx + r * Math.cos(angle);
                const py = cx - r * Math.sin(angle);
                
                ctx.fillStyle = '#0f766e';
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, TAU);
                ctx.fill();
                
                ctx.lineWidth = 3;
                ctx.font = '12px monospace';
                
                // Draw trigonometric lines
                if (active.has('sin')) {
                    ctx.strokeStyle = '#c62828';
                    ctx.beginPath();
                    ctx.moveTo(cx, cx);
                    ctx.lineTo(cx, py);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#222';
                    ctx.fillText(Math.sin(angle).toFixed(2), cx - 40, (py + cx) / 2);
                }
                
                if (active.has('cos')) {
                    ctx.strokeStyle = '#1565c0';
                    ctx.beginPath();
                    ctx.moveTo(cx, cx);
                    ctx.lineTo(px, cx);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#222';
                    ctx.fillText(Math.cos(angle).toFixed(2), (px + cx) / 2, cx + 20);
                }
                
                if (active.has('tan') && Math.abs(Math.cos(angle)) > 0.01) {
                    const tx = cx + r;
                    const tan_y = cx - r * Math.tan(angle);
                    
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#bbb';
                    ctx.beginPath();
                    ctx.moveTo(tx, cx - r - 30);
                    ctx.lineTo(tx, cx + r + 30);
                    ctx.stroke();
                    
                    ctx.textAlign = 'left';
                    ctx.font = '16px sans-serif';
                    ctx.fillStyle = '#222';
                    ctx.fillText('tan', tx - 10, cx - r - 12);
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(cx, cx);
                    ctx.lineTo(px, py);
                    ctx.lineTo(tx, tan_y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.strokeStyle = '#6a1b9a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(tx, cx);
                    ctx.lineTo(tx, tan_y);
                    ctx.stroke();
                }
                
                // Output display with both degrees and radians
                const deg = (angle * 180 / Math.PI).toFixed(1);
                const rad = formatRadians(angle);
                
                let output = `<strong>Angle:</strong> ${deg}Â° = ${rad}<br>`;
                
                if (lockedAngle !== null) {
                    const lockedDeg = (lockedAngle * 180 / Math.PI).toFixed(1);
                    const lockedRad = formatRadians(lockedAngle);
                    output += `<strong>Locked Î¸:</strong> ${lockedDeg}Â° = ${lockedRad}<br>`;
                    output += `<strong>Current:</strong> ${currentTransform.replace(/-/g, ' ')}<br>`;
                }
                
                output += '<br>';
                
                // Show identity relationships when locked
                if (lockedAngle !== null && currentTransform !== 'original') {
                    const expr = getTransformExpression();
                    const lockedRad = formatRadians(lockedAngle);
                    
                    [...active].forEach(func => {
                        const currentVal = getExactValue(func, angle);
                        
                        // Calculate the values we need
                        const sinLocked = Math.sin(lockedAngle);
                        const cosLocked = Math.cos(lockedAngle);
                        const tanLocked = Math.tan(lockedAngle);
                        const currentNum = { sin: Math.sin, cos: Math.cos, tan: Math.tan }[func](angle);
                        
                        let fullExpression = `<strong>${func}(${expr})</strong> = `;
                        
                        // Apply the correct trigonometric identity based on the transformation
                        switch (currentTransform) {
                            case 'negative':  // -Î¸
                                if (func === 'sin') {
                                    fullExpression += `-sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    fullExpression += `-tan(${lockedRad}) = ${currentVal}`;
                                }
                                break;
                                
                            case 'pi-minus':  // Ï€ - Î¸
                                if (func === 'sin') {
                                    fullExpression += `sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `-cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    fullExpression += `-tan(${lockedRad}) = ${currentVal}`;
                                }
                                break;
                                
                            case 'pi-plus':  // Ï€ + Î¸
                                if (func === 'sin') {
                                    fullExpression += `-sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `-cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    fullExpression += `tan(${lockedRad}) = ${currentVal}`;
                                }
                                break;
                                
                            case 'half-pi-plus':  // Ï€/2 + Î¸
                                if (func === 'sin') {
                                    fullExpression += `cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `-sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    if (Math.abs(cosLocked) > 0.001) {
                                        fullExpression += `-cot(${lockedRad}) = ${currentVal}`;
                                    } else {
                                        fullExpression += `undefined`;
                                    }
                                }
                                break;
                                
                            case 'half-pi-minus':  // Ï€/2 - Î¸
                                if (func === 'sin') {
                                    fullExpression += `cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    if (Math.abs(sinLocked) > 0.001) {
                                        fullExpression += `cot(${lockedRad}) = ${currentVal}`;
                                    } else {
                                        fullExpression += `undefined`;
                                    }
                                }
                                break;
                                
                            case 'two-pi-minus':  // 2Ï€ - Î¸
                                if (func === 'sin') {
                                    fullExpression += `-sin(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'cos') {
                                    fullExpression += `cos(${lockedRad}) = ${currentVal}`;
                                } else if (func === 'tan') {
                                    fullExpression += `-tan(${lockedRad}) = ${currentVal}`;
                                }
                                break;
                                
                            default:
                                fullExpression += `${currentVal}`;
                        }
                        
                        output += fullExpression + '<br>';
                    });
                } else {
                    // Normal display
                    [...active].forEach(func => {
                        const exactVal = getExactValue(func, angle);
                        output += `${func}(${deg}Â°) = ${exactVal}<br>`;
                    });
                }
                
                $('#unitOutput').innerHTML = output;
                drawWheel();
            }
            
            const rawAngle = (e, can) => {
                const rect = can.getBoundingClientRect();
                const c = can.width / 2;
                return Math.atan2(c - (e.clientY - rect.top), (e.clientX - rect.left) - c);
            };
            
            function move(e) {
                if (!dragging || lockedAngle !== null) return;
                const raw = rawAngle(e, dragCanvas);
                let delta = raw - prevRaw;
                if (delta > Math.PI) delta -= TAU;
                if (delta < -Math.PI) delta += TAU;
                angle = snap(angle + delta);
                prevRaw = raw;
                draw();
                updateAll();
            }
            
            function startDrag(e, can) {
                if (lockedAngle !== null) return;
                dragging = true;
                dragCanvas = can;
                prevRaw = rawAngle(e, can);
                move(e);
            }
            
            canvas.onpointerdown = e => startDrag(e, canvas);
            wheel.onpointerdown = e => startDrag(e, wheel);
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', () => {
                dragging = false;
                dragCanvas = null;
            });
            
            renders.unit = draw;
            draw();
        })();
        
        // Degrees â†” Radians Tab
        (() => {
            const degCtx = $('#degCanvas').getContext('2d');
            const radCtx = $('#radCanvas').getContext('2d');
            const C = $('#degCanvas').width / 2;
            const R = C - 10;
            const negCheck = $('#negCheck');
            let dragging = null;
            
            const gcd = (a, b) => b ? gcd(b, a % b) : a;
            
            const labelDeg = v => v + 'Â°';
            
            const labelRad = i => {
                if (i === 0) return '0';
                const n = i;
                const g = gcd(Math.abs(n), 12);
                const num = n / g;
                const den = 12 / g;
                return (num < 0 ? '-' : '') +
                    (Math.abs(num) === 1 ? 'Ï€' : Math.abs(num) + 'Ï€') +
                    (den === 1 ? '' : '/' + den);
            };
            
            function drawCircles() {
                [degCtx, radCtx].forEach(ctx => {
                    clear(ctx);
                    ctx.strokeStyle = '#0f766e';
                    ctx.lineWidth = 2;
                    circle(ctx, C, C, R);
                });
                
                const cw = negCheck.checked ? -1 : 1;
                
                for (let i = 0; i < 24; i++) {
                    const th = i * Math.PI / 12 * cw;
                    const x = C + R * Math.cos(th);
                    const y = C - R * Math.sin(th);
                    
                    [degCtx, radCtx].forEach(ctx => {
                        ctx.strokeStyle = '#bbb';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(C + 0.9 * R * Math.cos(th), C - 0.9 * R * Math.sin(th));
                        ctx.stroke();
                    });
                    
                    if (i % 3 === 0) {
                        degCtx.textAlign = radCtx.textAlign = 'center';
                        degCtx.textBaseline = radCtx.textBaseline = 'middle';
                        degCtx.fillStyle = radCtx.fillStyle = '#0f766e';
                        degCtx.font = radCtx.font = '14px sans-serif';
                        
                        degCtx.fillText(labelDeg(i * 15 * cw),
                            C + 0.75 * R * Math.cos(th),
                            C - 0.75 * R * Math.sin(th));
                        
                        radCtx.fillText(labelRad(i * cw),
                            C + 0.75 * R * Math.cos(th),
                            C - 0.75 * R * Math.sin(th));
                    }
                }
            }
            
            function drawPointer() {
                const x = C + R * Math.cos(angle);
                const y = C - R * Math.sin(angle);
                
                [degCtx, radCtx].forEach(ctx => {
                    ctx.fillStyle = '#0f766e';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, TAU);
                    ctx.fill();
                });
            }
            
            function draw() {
                drawCircles();
                drawPointer();
            }
            
            const angleFromEvent = (e, cv) => {
                const rect = cv.getBoundingClientRect();
                return Math.atan2(
                    cv.height / 2 - (e.clientY - rect.top),
                    (e.clientX - rect.left) - cv.width / 2
                );
            };
            
            function move(e) {
                if (!dragging) return;
                angle = snap(angleFromEvent(e, dragging === 'deg' ? $('#degCanvas') : $('#radCanvas')));
                draw();
                updateAll();
            }
            
            $('#degCanvas').onpointerdown = e => {
                dragging = 'deg';
                move(e);
            };
            
            $('#radCanvas').onpointerdown = e => {
                dragging = 'rad';
                move(e);
            };
            
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', () => dragging = null);
            
            negCheck.onchange = draw;
            
            renders.deg = draw;
            draw();
        })();
        
        // Graph Tab
        (() => {
            const uc = $('#graphUnitCircle');
            const uctx = uc.getContext('2d');
            const gp = $('#graphPlot');
            const gctx = gp.getContext('2d');
            const CC = uc.width / 2;
            const R = CC - 30;
            let dragging = false;
            const range = [-2 * Math.PI, 2 * Math.PI];
            
            function drawUnitCircle() {
                clear(uctx);
                uctx.lineWidth = 1;
                uctx.strokeStyle = '#000';
                circle(uctx, CC, CC, R);
                
                // Axes
                uctx.strokeStyle = '#bbb';
                uctx.beginPath();
                uctx.moveTo(CC - R - 20, CC);
                uctx.lineTo(CC + R + 20, CC);
                uctx.moveTo(CC, CC - R - 20);
                uctx.lineTo(CC, CC + R + 20);
                uctx.stroke();
                
                uctx.font = '14px sans-serif';
                uctx.fillStyle = '#222';
                uctx.textAlign = 'left';
                uctx.fillText('cos', CC + R + 5, CC + 5);
                uctx.textAlign = 'center';
                uctx.fillText('sin', CC, CC - R - 10);
                
                const px = CC + R * Math.cos(angle);
                const py = CC - R * Math.sin(angle);
                
                uctx.fillStyle = '#0f766e';
                uctx.beginPath();
                uctx.arc(px, py, 5, 0, TAU);
                uctx.fill();
                
                uctx.lineWidth = 3;
                const fn = $('#graphFunc').value;
                
                if (fn === 'sin') {
                    uctx.strokeStyle = '#c62828';
                    uctx.beginPath();
                    uctx.moveTo(CC, CC);
                    uctx.lineTo(CC, py);
                    uctx.stroke();
                } else if (fn === 'cos') {
                    uctx.strokeStyle = '#1565c0';
                    uctx.beginPath();
                    uctx.moveTo(CC, CC);
                    uctx.lineTo(px, CC);
                    uctx.stroke();
                } else {
                    const tx = CC + R;
                    const tan_y = CC - R * Math.tan(angle);
                    
                    uctx.lineWidth = 1;
                    uctx.strokeStyle = '#bbb';
                    uctx.beginPath();
                    uctx.moveTo(tx, CC - R - 20);
                    uctx.lineTo(tx, CC + R + 20);
                    uctx.stroke();
                    
                    uctx.textAlign = 'left';
                    uctx.font = '14px sans-serif';
                    uctx.fillStyle = '#222';
                    uctx.fillText('tan', tx - 10, CC - R - 5);
                    
                    uctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    uctx.setLineDash([4, 4]);
                    uctx.beginPath();
                    uctx.moveTo(CC, CC);
                    uctx.lineTo(px, py);
                    uctx.lineTo(tx, tan_y);
                    uctx.stroke();
                    uctx.setLineDash([]);
                    
                    uctx.strokeStyle = '#6a1b9a';
                    uctx.lineWidth = 3;
                    uctx.beginPath();
                    uctx.moveTo(tx, CC);
                    uctx.lineTo(tx, tan_y);
                    uctx.stroke();
                }
            }
            
            function plotGraph() {
                clear(gctx);
                const [x0, x1] = range;
                const w = gp.width;
                const h = gp.height;
                const sx = w / (x1 - x0);
                const sy = h / 2 * 0.9;
                const ox = -x0 * sx;
                const oy = h / 2;
                
                // Axes
                gctx.strokeStyle = '#bbb';
                gctx.beginPath();
                gctx.moveTo(0, oy);
                gctx.lineTo(w, oy);
                gctx.moveTo(ox, 0);
                gctx.lineTo(ox, h);
                gctx.stroke();
                
                const fn = $('#graphFunc').value;
                const F = { sin: Math.sin, cos: Math.cos, tan: Math.tan }[fn];
                
                gctx.strokeStyle = '#0f766e';
                gctx.lineWidth = 2;
                gctx.beginPath();
                
                let first = true;
                for (let x = x0; x <= x1; x += 0.02) {
                    let y = F(x);
                    if (!isFinite(y)) {
                        first = true;
                        continue;
                    }
                    
                    const px = ox + x * sx;
                    const py = oy - y * sy;
                    
                    if (first) {
                        gctx.moveTo(px, py);
                        first = false;
                    } else {
                        gctx.lineTo(px, py);
                    }
                }
                gctx.stroke();
                
                // Asymptotes for tan
                if (fn === 'tan') {
                    gctx.strokeStyle = '#aaa';
                    gctx.setLineDash([4, 4]);
                    for (let k = Math.ceil(x0 / (Math.PI / 2));
                         k <= Math.floor(x1 / (Math.PI / 2)); k++) {
                        if (k % 2 === 0) continue;
                        const px = ox + k * Math.PI / 2 * sx;
                        gctx.beginPath();
                        gctx.moveTo(px, 0);
                        gctx.lineTo(px, h);
                        gctx.stroke();
                    }
                    gctx.setLineDash([]);
                }
                
                // Current value point
                const vx = ox + angle * sx;
                const vy = oy - F(angle) * sy;
                
                gctx.fillStyle = '#c62828';
                gctx.beginPath();
                gctx.arc(vx, vy, 5, 0, TAU);
                gctx.fill();
                
                gctx.strokeStyle = '#c62828';
                gctx.beginPath();
                gctx.moveTo(vx, vy);
                gctx.lineTo(vx, oy);
                gctx.stroke();
            }
            
            function redraw() {
                drawUnitCircle();
                plotGraph();
            }
            
            function getAngle(e) {
                const rect = uc.getBoundingClientRect();
                return Math.atan2(
                    CC - (e.clientY - rect.top),
                    (e.clientX - rect.left) - CC
                );
            }
            
            function move(e) {
                if (!dragging) return;
                angle = snap(getAngle(e));
                redraw();
                updateAll();
            }
            
            uc.onpointerdown = e => {
                dragging = true;
                move(e);
            };
            
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', () => dragging = false);
            
            $('#graphFunc').onchange = redraw;
            
            renders.graph = redraw;
            redraw();
        })();
    </script>
</body>
</html>
