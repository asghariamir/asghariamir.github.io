<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>شبکه ضرب  </title>
    <style>
        :root {
            --primary-color: #1565c0;
            --secondary-color: #2e7d32;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #424242;
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        /* Use a Farsi-compatible font */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Vazirmatn', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.8;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            display: flex;
            justify-content: center;
            padding: 1rem;
        }
        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }
        h2 {
            font-size: 1.75rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }
        
        /* Styled Info Panels */
        #infoPanel, #equation, .farsi-guide {
            padding: 1rem;
            background-color: var(--light-gray);
            border-radius: 6px;
            margin: 1.5rem 0;
            min-height: 2.5em;
            font-weight: 600;
            font-size: 1.1rem;
            text-align: right; /* Right-align Farsi text */
        }
        #equation { font-family: monospace; text-align: center; }
        .farsi-guide h3 { font-size: 1.2rem; color: var(--primary-color); margin-bottom: 0.5rem;}
        .farsi-guide p { font-size: 1rem; font-weight: normal; margin-bottom: 0.5rem;}
        .farsi-guide li { margin-right: 1.5rem; }

        /* Grid styling */
        .grid-wrapper { display: inline-block; margin-top: 1.5rem; }
        .header, .left-header {
            background-color: var(--medium-gray);
            gap: 1px;
        }
        .header {
            display: grid;
            grid-template-columns: 40px repeat(12, 40px);
        }
        .left-header {
            display: grid;
            grid-template-rows: repeat(12, 40px);
        }
        .header div, .left-header div {
            width: 40px;
            height: 40px;
            background-color: var(--light-gray);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--medium-gray);
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            gap: 1px;
            background-color: var(--medium-gray);
            margin-right: 1px; /* Flipped from margin-left for RTL */
            cursor: crosshair;
        }
        .cell {
            width: 40px;
            height: 40px;
            background: #fff;
            border: 1px solid var(--medium-gray);
            transition: background-color 0.2s;
            font-size: 1.2rem;
            color: var(--primary-color);
        }
        .cell:hover { background-color: #e3f2fd; }

        /* Piece Colors */
        .piece-red { background: rgba(21, 101, 192, 0.25); }
        .piece-green{ background: rgba(46, 125, 50, 0.25); }
        .temp-piece { background: rgba(255, 235, 59, 0.4); }
        .overlap-piece {
            background-image: repeating-linear-gradient(45deg, rgba(0, 0, 0, 0.2) 0 4px, rgba(0, 0, 0, 0.0) 4px 8px);
            border: 2px solid var(--dark-gray) !important;
        }
        
        /* Headers highlight */
        .row-highlight-red, .col-highlight-red { color: var(--primary-color); }
        .row-highlight-green, .col-highlight-green { color: var(--secondary-color); }

        /* Button Styling */
        button {
            margin-top: 1.5rem;
            padding: 10px 20px;
            background: #d32f2f;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #c62828; }
    </style>
</head>
<body dir="rtl">
<div class="container">
    <h2>شبکه ضرب</h2>
    
    <div class="farsi-guide">
        <h3>راهنمای کوتاه (فارسی)</h3>
        <ul>
            <li>ابتدا مستطیلی را که می‌خواهید حاصل ضرب آن را پیدا کنید انتخاب کنید – با رنگ آبی نمایش داده می‌شود.</li>
            <li>سپس مستطیلی را که حاصل ضرب آن را می‌دانید انتخاب کنید؛ این مستطیل باید کاملاً درون مستطیل اول قرار بگیرد یا کاملاً آن را احاطه کند – با رنگ سبز نمایش داده می‌شود.</li>
            <li>شکاف باقی‌مانده را با کشیدن مستطیل‌ پُر کنید. معمولاً یک نوار پایین و یک نوار سمت راست کافی است؛ گاهی فقط یک قطعه لازم است. اگر گوشهٔ مشترکی به‌وجود بیاید، برنامه به‌طور خودکار آن را مدیریت می‌کند.</li>
        </ul>
        <p><b>مثال:</b> برای محاسبهٔ ۷×۶، ابتدا آن را انتخاب کنید. اگر ۵×۵ را بلد هستید، آن را به‌عنوان مستطیل شناخته‌شده برگزینید. سپس یک نوار ۷×۱ در پایین و یک نوار ۶×۲ در سمت راست اضافه می‌کنید؛ مربع اشتراکی ۲×۱ در گوشه به‌طور خودکار لحاظ می‌شود.</p>
    </div>

    <div id="infoPanel">یک مستطیل (حاصل‌ضرب) را که <strong>می‌خواهید پیدا کنید</strong> انتخاب نمایید.</div>
    <div id="equation"></div>

    <div class="grid-wrapper">
        <div>
            <div id="topHeader" class="header"></div>
            <div style="display:flex;">
                <div id="leftHeader" class="left-header"></div>
                <div id="grid" class="grid"></div>
            </div>
        </div>
    </div>

    <button onclick="location.reload()">پاک کردن همه</button>
</div>

<script>
// This is your working JavaScript, with only the user-facing text translated.
/******************** Utility functions ********************/
function buildHeaders(){
    const top = document.getElementById('topHeader');
    const left = document.getElementById('leftHeader');
    top.appendChild(document.createElement('div'));
    for(let c=1;c<=12;c++){
        const d=document.createElement('div');d.textContent=c;d.className='colHeader';d.dataset.col=c;top.appendChild(d);
    }
    for(let r=1;r<=12;r++){
        const d=document.createElement('div');d.textContent=r;d.className='rowHeader';d.dataset.row=r;left.appendChild(d);
    }
}
function outlineRect(rect,color){
    const th=`3px solid ${color}`;
    document.querySelectorAll('.cell').forEach(cell=>{
        const r=+cell.dataset.row, c=+cell.dataset.col;
        cell.style.border = `1px solid var(--medium-gray)`;
        if(r<=rect.rows && c<=rect.cols){
            if(r===1)         cell.style.borderTop    = th;
            if(c===1)         cell.style.borderLeft   = th;
            if(r===rect.rows) cell.style.borderBottom = th;
            if(c===rect.cols) cell.style.borderRight  = th;
        }
    });
}
function fillRect(rect,cls){
    document.querySelectorAll('.cell').forEach(cell=>{
        const r=+cell.dataset.row, c=+cell.dataset.col;
        if(r<=rect.rows && c<=rect.cols) cell.classList.add(cls);
    });
}
function resetVisual(){
    document.querySelectorAll('.cell').forEach(cell=>{
        cell.className='cell'; cell.style.border='';
        cell.style.backgroundImage=''; cell.style.backgroundColor='';
    });
    document.querySelectorAll('.rowHeader').forEach(h=>h.className='header-cell rowHeader');
    document.querySelectorAll('.colHeader').forEach(h=>h.className='header-cell colHeader');
    document.getElementById('equation').textContent='';
}
function highlightHeaders(rect,color){
    try{
        document.querySelector(`.rowHeader[data-row='${rect.rows}']`).classList.add(`row-highlight-${color}`);
        document.querySelector(`.colHeader[data-col='${rect.cols}']`).classList.add(`col-highlight-${color}`);
    }catch(e){console.warn('Header highlight issue',e);}
}
/******************** Main ********************/
window.addEventListener('DOMContentLoaded',()=>{
    const grid = document.getElementById('grid');
    const info = document.getElementById('infoPanel');
    const eq   = document.getElementById('equation');

    buildHeaders();
    for(let r=1;r<=12;r++){
        for(let c=1;c<=12;c++){
            const cell=document.createElement('div');
            cell.className='cell'; cell.dataset.row=r; cell.dataset.col=c;
            grid.appendChild(cell);
        }
    }

    let stage=0, target=null, known=null, outer=null, inner=null;
    let missing=[], hueIdx=0, drawing=false, startCell=null;

    const area   = r => r.rows*r.cols;
    const nested = (a,b)=> (a.rows>=b.rows && a.cols>=b.cols) || (b.rows>=a.rows && b.cols>=a.cols);
    const insideOuter = cell => outer && (+cell.dataset.row)<=outer.rows && (+cell.dataset.col)<=outer.cols && !((+cell.dataset.row)<=inner.rows && (+cell.dataset.col)<=inner.cols);

    function computePieces(){
        missing = [];
        const dr = outer.rows - inner.rows;
        const dc = outer.cols - inner.cols;
        const stripSign = outer===target ? +1 : -1;
        if(dc>0) missing.push({ rows: outer.rows, cols: dc, startRow: 1, startCol: inner.cols+1, filled:false, sign: stripSign });
        if(dr>0) missing.push({ rows: dr, cols: inner.cols, startRow: inner.rows+1, startCol: 1, filled:false, sign: stripSign });
    }

    function renderEquation(constants){
        const {dr,dc,stripSign} = constants;
        let eqHTML = `${target.rows}×${target.cols} = ${known.rows}×${known.cols}`;
        missing.forEach((p,i)=>{
            const sym = p.sign>0 ? ' + ' : ' - ';
            eqHTML += `${sym}<span id="p${i}">___</span>`;
        });
        if(dr>0 && dc>0){
            const sym = stripSign>0 ? ' - ' : ' + ';
            eqHTML += `${sym}${dr}×${dc}`;
        }
        eq.innerHTML = eqHTML;
    }

    function updateEq(){
        missing.forEach((p,i)=>{
            if(p.filled){
                document.getElementById(`p${i}`).textContent = `${p.rows}×${p.cols}`;
            }
        });
    }

    function setupPuzzle(){
        outer = area(target)>=area(known)? target : known;
        inner = outer===target ? known : target;
        resetVisual();
        fillRect(inner, inner===target?'piece-red':'piece-green');
        outlineRect(outer, outer===target ? '#1565c0' : '#2e7d32');
        highlightHeaders(target,'red');
        highlightHeaders(known,'green');
        const constants = computePieces();
        renderEquation(constants);
        stage = 2;
        info.textContent = 'قطعات لازم برای تکمیل قاب را بکشید.';
    }

    function previewTemp(start,cur){
        document.querySelectorAll('.temp-piece').forEach(c=>c.classList.remove('temp-piece'));
        const sr=+start.dataset.row, sc=+start.dataset.col,
              er=+cur.dataset.row,   ec=+cur.dataset.col;
        const minR=Math.min(sr,er), maxR=Math.max(sr,er),
              minC=Math.min(sc,ec), maxC=Math.max(sc,ec);
        for(let r=minR;r<=maxR;r++)
            for(let c=minC;c<=maxC;c++){
                const cell=document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
                if(cell && insideOuter(cell)) cell.classList.add('temp-piece');
            }
    }

    function commitPiece(){
        const cells=[...document.querySelectorAll('.temp-piece')];
        if(!cells.length) return;
        const rs=cells.map(c=>+c.dataset.row), cs=cells.map(c=>+c.dataset.col);
        const rect={
            startRow:Math.min(...rs), startCol:Math.min(...cs),
            rows:Math.max(...rs)-Math.min(...rs)+1, cols:Math.max(...cs)-Math.min(...cs)+1
        };
        const idx=missing.findIndex(p=>!p.filled && p.rows===rect.rows && p.cols===rect.cols && p.startRow===rect.startRow && p.startCol===rect.startCol);
        if(idx===-1){
            alert('اندازه یا مکان قطعه نادرست است. دوباره تلاش کنید.');
            cells.forEach(c=>c.classList.remove('temp-piece'));
            return;
        }
        const col = `hsla(${(hueIdx*67)%360},100%,50%,0.55)`; hueIdx++;
        cells.forEach(c=>{
            c.classList.remove('temp-piece');
            if(c.classList.contains('user-piece')){
                c.classList.add('overlap-piece');
            }else{
                c.classList.add('user-piece');
                c.style.backgroundColor = col;
            }
        });
        missing[idx].filled = true;
        updateEq();
        if(missing.every(p=>p.filled)) info.textContent = 'پازل کامل شد! مربع‌های راه‌راه نشان‌دهندهٔ ناحیهٔ مشترک هستند.';
    }

    grid.addEventListener('mousedown',e=>{
        const cell = e.target.closest('.cell');
        if(!cell) return;
        if(stage===0){
            target={rows:+cell.dataset.row, cols:+cell.dataset.col};
            fillRect(target,'piece-red');
            outlineRect(target,'#1565c0');
            highlightHeaders(target,'red');
            stage=1;
            info.textContent='حالا یک حاصل‌ضرب را که بلد هستید انتخاب کنید (باید درون اولی قرار گیرد).';
        }else if(stage===1){
            known={rows:+cell.dataset.row, cols:+cell.dataset.col};
            if(!nested(target,known)){
                alert('به یاد داشته باشید: یکی از مستطیل‌ها باید درون دیگری باشد.');
                return;
            }
            setupPuzzle();
        }else if(stage===2 && insideOuter(cell)){
            drawing=true;
            startCell=cell;
            previewTemp(cell,cell);
        }
    });
    grid.addEventListener('mousemove',e=>{
        if(drawing && stage===2){
            const cell=e.target.closest('.cell');
            if(cell) previewTemp(startCell,cell);
        }
    });
    window.addEventListener('mouseup',()=>{
        if(drawing){
            commitPiece();
            drawing=false;
            startCell=null;
        }
    });
});
</script>
</body>
</html>
