<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cantor-Set Explorer & Box-Dimension Lab</title>

<!-- ========== Styling ========== -->
<style>
  /* ── basics ── */
  html,body{margin:0;padding:0;font-family:system-ui,sans-serif;background:#fff;color:#000}
  h1{margin:18px 0;font-weight:700}
  button,input[type=range]{cursor:pointer;user-select:none}
  input[type=range]{accent-color:#1976d2}

  /* ── layout helpers ── */
  .flex        {display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .column      {display:flex;flex-direction:column;gap:14px}
  .tab-buttons {margin-bottom:14px;display:flex;gap:6px}
  .tab-buttons button{
    padding:6px 18px;border:1px solid #777;border-radius:6px;background:#f8f8f8;
    transition:background .2s,font-weight .2s
  }
  .tab-buttons button.active{background:#1976d2;color:#fff;font-weight:600}

  /* ── canvases ── */
  #cantorCanvas{border:1px solid #ccc}
  #boxesCanvas{border:1px solid #ccc;margin-top:6px}

  /* ── data table ── */
  table{border-collapse:collapse;width:100%;margin-top:6px}
  th,td{padding:4px 8px;text-align:right}
  th{background:#f0f0f0}
  tr:nth-child(even){background:#fafafa}
</style>

<!-- ── Chart.js for log-log plot ── -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
</head>
<body>

<h1>Cantor-Set Explorer</h1>

<!-- ========== Tab bar ========== -->
<div class="tab-buttons">
  <button id="tabExplorer"  class="active">Set Explorer</button>
  <button id="tabDimension">Box Dimension</button>
</div>

<!-- ===================== 1. SET EXPLORER ===================== -->
<div id="explorerSection">
  <!-- canvas + controls -->
  <div class="column">
    <canvas id="cantorCanvas" width="1000" height="120"></canvas>

    <div class="flex">
      <label for="depthRange">Depth n</label>
      <input type="range" id="depthRange" min="0" max="9" step="1" value="5">
      <span id="depthVal">5</span>

      <button id="animateBtn">Animate</button>
      <button id="resetZoomBtn">Reset view</button>
    </div>
  </div>
</div>

<!-- ===================== 2. BOX DIMENSION LAB ===================== -->
<div id="dimensionSection" style="display:none">
  <!-- controls -->
  <div class="column">
    <!-- line 1 -->
    <div class="flex">
      <label for="kRange">k (box size = 3<sup>-k</sup>)</label>
      <input type="range" id="kRange" min="1" max="9" step="1" value="4">
      <span id="kVal">4</span>
    </div>
    <!-- line 2 -->
    <div class="flex">
      <span id="sDisplay">s = 0.01235</span>
      <span id="nDisplay">N(s) = 20</span>
    </div>
    <!-- line 3 -->
    <div class="flex">
      <button id="addRowBtn">Add data row</button>
      <button id="plotBtn">Plot log-log</button>
      <button id="fitBtn">Fit line & slope</button>
    </div>

    <!-- little box-occupancy diagram -->
    <canvas id="boxesCanvas" width="1000" height="40"></canvas>

    <!-- data table -->
    <table id="dataTable">
      <thead><tr><th>k</th><th>Box size s</th><th>Occupied boxes N(s)</th></tr></thead>
      <tbody></tbody>
    </table>

    <!-- chart -->
    <canvas id="chartCanvas" width="1000" height="300"></canvas>
  </div>
</div>

<!-- ============================================================= -->
<script>
/* ---------------- Utility: build segments at depth n ---------------- */
function buildLevels(n){
  let current=[[0,1]], levels=[current];
  for(let d=0;d<n;d++){
    const next=[];
    current.forEach(([s,e])=>{
      const len=e-s;
      next.push([s, s+len/3], [e-len/3, e]);
    });
    current=next;
    levels.push(current);
  }
  return levels;                     // array of segment arrays depth 0..n
}

/* ====================================================================
   SECTION 1 — SET EXPLORER  (zoom & pan)
   ==================================================================== */
const canvas      = document.getElementById('cantorCanvas');
const ctx         = canvas.getContext('2d');
const depthRange  = document.getElementById('depthRange');
const depthVal    = document.getElementById('depthVal');
const animateBtn  = document.getElementById('animateBtn');
const resetZoomBtn= document.getElementById('resetZoomBtn');

let animTimer=null, dir=1;
const view={start:0, end:1};         // visible x-window in [0,1]

function drawExplorer(){
  const n=+depthRange.value;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // grey background boxes for visual context
  const numPixels=canvas.width;
  ctx.fillStyle='#e0e0e0';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle='#1976d2';
  const segments=buildLevels(n)[n];           // only deepest level
  segments.forEach(([s,e])=>{
    // clip by current view
    const L=Math.max(s,view.start), R=Math.min(e,view.end);
    if(L>=R) return;
    const x=LToPx(L), w=LToPx(R)-LToPx(L);
    ctx.fillRect(x,0,w,canvas.height);
  });
}

/* ----- helpers for view mapping ----- */
function LToPx(x){return (x-view.start)/(view.end-view.start)*canvas.width;}
function PxToL(px){return px/canvas.width*(view.end-view.start)+view.start;}

/* ----- zoom (wheel) ----- */
canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const zoomFactor=e.deltaY<0?0.8:1.25;          // in/out
  const mouseX=PxToL(e.offsetX);
  const newSpan=(view.end-view.start)*zoomFactor;
  let newStart=mouseX-(mouseX-view.start)*zoomFactor;
  let newEnd  =newStart+newSpan;

  // clamp
  if(newStart<0){newEnd-=newStart;newStart=0;}
  if(newEnd>1){newStart-=newEnd-1;newEnd=1;}
  view.start=Math.max(0,newStart);
  view.end  =Math.min(1,newEnd);
  drawExplorer();
},{passive:false});

/* ----- pan (drag) ----- */
let dragging=false,lastX=0;
canvas.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX});
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX;
  lastX=e.clientX;
  const span=view.end-view.start;
  const shift=dx/canvas.width*span;
  view.start=Math.max(0,view.start-shift);
  view.end  =Math.min(1,view.end-shift);
  if(view.start<0){view.end-=view.start;view.start=0;}
  if(view.end>1){view.start-=view.end-1;view.end=1;}
  drawExplorer();
});
window.addEventListener('mouseup',()=>dragging=false);

/* ----- reset view ----- */
resetZoomBtn.onclick=()=>{view.start=0;view.end=1;drawExplorer()};

/* ----- depth/animation ----- */
function refreshExplorer(){
  depthVal.textContent=depthRange.value;
  drawExplorer();
}
depthRange.oninput=()=>{stopAnim();refreshExplorer();};
function startAnim(){
  animateBtn.textContent='Stop';
  animTimer=setInterval(()=>{
    let d=+depthRange.value;
    if(d>=+depthRange.max)dir=-1;
    if(d<=+depthRange.min)dir=1;
    depthRange.value=d+dir;
    refreshExplorer();
  },600);
}
function stopAnim(){clearInterval(animTimer);animTimer=null;animateBtn.textContent='Animate'}
animateBtn.onclick=()=>animTimer?stopAnim():startAnim();

/* ====================================================================
   SECTION 2 — BOX DIMENSION
   ==================================================================== */
const kRange     = document.getElementById('kRange');
const kVal       = document.getElementById('kVal');
const sDisplay   = document.getElementById('sDisplay');
const nDisplay   = document.getElementById('nDisplay');
const boxesCv    = document.getElementById('boxesCanvas');
const boxesCtx   = boxesCv.getContext('2d');
const addRowBtn  = document.getElementById('addRowBtn');
const plotBtn    = document.getElementById('plotBtn');
const fitBtn     = document.getElementById('fitBtn');
const dataBody   = document.querySelector('#dataTable tbody');
const chartCv    = document.getElementById('chartCanvas');

let chart=null;                      // Chart.js instance

function countAndDrawBoxes(){
  const k=+kRange.value;
  const s=Math.pow(1/3,k);           // box length
  const n=+depthRange.value;         // current recursion depth
  const segments=buildLevels(n)[n];

  let occupied=0;
  const boxes= Math.ceil(1/s);
  boxesCtx.clearRect(0,0,boxesCv.width,boxesCv.height);
  for(let i=0;i<boxes;i++){
    const boxStart=i*s, boxEnd=(i+1)*s;
    const hit=segments.some(([a,b])=>!(b<=boxStart||a>=boxEnd));
    if(hit) occupied++;

    // draw column
    const x=i/boxes*boxesCv.width, w=boxesCv.width/boxes;
    boxesCtx.fillStyle=hit?'#1976d2':'#e0e0e0';
    boxesCtx.fillRect(x,0,w,boxesCv.height);
  }
  return {s,occupied};
}
function refreshDimension(){
  kVal.textContent=kRange.value;
  const {s,occupied}=countAndDrawBoxes();
  sDisplay.textContent=`s = ${s.toPrecision(4)}`;
  nDisplay.textContent=`N(s) = ${occupied}`;
}
kRange.oninput=refreshDimension;

/* ----- add data row ----- */
function addRow(){
  const k=+kRange.value;
  const {s,occupied}=countAndDrawBoxes();
  const tr=document.createElement('tr');
  tr.innerHTML=`<td>${k}</td><td>${s.toExponential(3)}</td><td>${occupied}</td>`;
  dataBody.appendChild(tr);
}
addRowBtn.onclick=addRow;

/* ----- plot log-log ----- */
function plot(){
  const rows=[...dataBody.querySelectorAll('tr')];
  if(!rows.length){alert('Add some data first!');return;}
  const xs=[], ys=[];
  rows.forEach(r=>{
    const s=+r.children[1].textContent;
    const N=+r.children[2].textContent;
    xs.push(Math.log(1/s));
    ys.push(Math.log(N));
  });
  if(chart) chart.destroy();
  chart=new Chart(chartCv,{
    type:'scatter',
    data:{datasets:[{data:xs.map((x,i)=>({x, y:ys[i]}))}]},
    options:{
      scales:{
        x:{type:'linear',title:{text:'log(1/s)',display:true}},
        y:{type:'linear',title:{text:'log N(s)',display:true}}
      },
      plugins:{legend:{display:false}}
    }
  });
}
plotBtn.onclick=plot;

/* ----- fit line & slope ----- */
function fitLine(){
  const rows=[...dataBody.querySelectorAll('tr')];
  if(rows.length<2){alert('Need at least 2 points');return;}
  const xs=[], ys=[];
  rows.forEach(r=>{
    const s=+r.children[1].textContent;
    const N=+r.children[2].textContent;
    xs.push(Math.log(1/s));
    ys.push(Math.log(N));
  });
  // least-squares
  const n=xs.length;
  const sumX=xs.reduce((a,b)=>a+b,0);
  const sumY=ys.reduce((a,b)=>a+b,0);
  const sumXY=xs.reduce((a,b,i)=>a+b*ys[i],0);
  const sumX2=xs.reduce((a,b)=>a+b*b,0);
  const slope=(n*sumXY-sumX*sumY)/(n*sumX2-sumX*sumX);
  const intercept=(sumY-slope*sumX)/n;

  // draw line on chart
  if(!chart){plot()}   // ensure chart exists
  const lineX=[Math.min(...xs),Math.max(...xs)];
  const lineData=lineX.map(x=>({x,y:slope*x+intercept}));
  chart.data.datasets[1]={
    type:'line',
    data:lineData,
    borderWidth:1,
    borderDash:[6,4],
    pointRadius:0
  };
  chart.update();

  // show slope
  if(!document.getElementById('slopeLabel')){
    const lbl=document.createElement('p');
    lbl.id='slopeLabel';
    chartCv.parentElement.insertBefore(lbl,chartCv.nextSibling);
  }
  document.getElementById('slopeLabel').textContent=`Estimated dimension ≈ ${slope.toFixed(4)}`;
}
fitBtn.onclick=fitLine;

/* ====================================================================
   TABS
   ==================================================================== */
const tabExplorer=document.getElementById('tabExplorer');
const tabDimension=document.getElementById('tabDimension');
tabExplorer.onclick=()=>{
  tabExplorer.classList.add('active');
  tabDimension.classList.remove('active');
  explorerSection.style.display='';
  dimensionSection.style.display='none';
};
tabDimension.onclick=()=>{
  tabDimension.classList.add('active');
  tabExplorer.classList.remove('active');
  explorerSection.style.display='none';
  dimensionSection.style.display='';
};

/* ----- initial paints ----- */
refreshExplorer();
refreshDimension();
</script>
</body>
</html>

  
